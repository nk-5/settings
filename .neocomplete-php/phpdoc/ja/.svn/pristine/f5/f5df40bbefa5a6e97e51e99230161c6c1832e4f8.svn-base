<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 297078 Maintainer: takagi Status: ready -->
 <sect2 xml:id="internals2.ze1.zendapi.variables" xmlns="http://docbook.org/ns/docbook"> 
  <title>変数の作成</title>
  <para>
   あなたの作成する拡張モジュールが PHP スクリプトとの間でデータ交換を行うにあたって、
   もっとも重要な問題は変数の作成です。この節では、
   PHP がサポートする変数の型を扱う方法を示します。
  </para> 
  <sect3 xml:id="internals2.ze1.zendapi.variables.overview"> 
   <title>概要</title> 
   <para>
    実行中のスクリプトによって「外部から」見える変数を新しく作成するには、
    まず新しい <envar>zval</envar> コンテナを確保してそこに値を格納し、
    それを Zend の内部シンボルテーブルに登録しなければなりません。
    これは、変数を作成する際のお決まりの手順です。
   </para>
   <programlisting role="c">
<![CDATA[
zval *new_variable; 

/* 新しいコンテナを確保して初期化します */
MAKE_STD_ZVAL(new_variable); 

/* 型や値をここで設定します。これ以降の節を参照ください */ 

/* この変数を "new_variable_name" という名前でシンボルテーブルに登録します */
ZEND_SET_SYMBOL(EG(active_symbol_table), "new_variable_name", new_variable); 

/* これで、$new_variable_name という名前でスクリプトからアクセスできるようになります */ 
]]>
   </programlisting>
   <para>
    マクロ <literal>MAKE_STD_ZVAL</literal> は、<literal>ALLOC_ZVAL</literal>
    を使用して新しい <envar>zval</envar> コンテナを確保し、
    <literal>INIT_ZVAL</literal> でそれを初期化します。
    これを書いている時点の Zend の実装では、<emphasis>初期化</emphasis>
    というのは参照カウンタを <literal>1</literal> にして
    <envar>is_ref</envar> フラグをクリアすることを指します。
    しかし、これは今後拡張される可能性があります。そのため、
    <literal>ALLOC_ZVAL</literal> を直接使用するのではなく
    <literal>MAKE_STD_ZVAL</literal> を用いるようにしておくことが大切です。
    実行速度を最適化したい場合 (そして、ここで明示的に
    <envar>zval</envar> コンテナを初期化する必要がない場合)
    は <literal>ALLOC_ZVAL</literal> を使用することも可能です。
    しかし、データの整合性を保証できなくなるため、
    この方法は推奨されません。
   </para> 
   <para>
    <literal>ZEND_SET_SYMBOL</literal> の役割は、新しい変数を
    Zend のシンボルテーブルに登録することです。このマクロは、
    その値が既にシンボルテーブルに存在するかどうかを調べ、
    もし存在すれば新しいシンボルを参照に変換します
    (古い <envar>zval</envar> コンテナが使用していたメモリは、
    自動的に開放されます)。速度を気にする必要がない場合には
    この方法がお勧めです。メモリの使用量を抑えることができます。
   </para> 
   <para>
    <literal>ZEND_SET_SYMBOL</literal> は、マクロ <literal>EG</literal>
    経由で Zend executor のグローバル変数を使用することに注意しましょう。
    <literal>EG(active_symbol_table)</literal> を指定することで、
    現在アクティブなシンボルテーブルを、アクティブなローカルスコープで扱えるようになります。
    ローカルスコープは、その関数が関数内でコールされたかどうかによって異なります。
   </para> 
   <para>
    とにかく速度を最適化したい、メモリの消費量はあまり気にしない
    という場合には、同じ値が既存の変数に登録されているかどうかの
    チェックを省略することができます。その代わりに、
    <function>zend_hash_update</function> を使用して
    強制的にシンボルテーブルに挿入します。
    <programlisting role="c">
<![CDATA[
zval *new_variable;

/* 新しいコンテナを確保して初期化します */
MAKE_STD_ZVAL(new_variable);

/* 型や値をここで設定します。これ以降の節を参照ください */ 

/* この変数を "new_variable_name" という名前でシンボルテーブルに登録します */
zend_hash_update(
    EG(active_symbol_table),
    "new_variable_name",
    strlen("new_variable_name") + 1,
    &new_variable,
    sizeof(zval *),
    NULL
);
]]>
    </programlisting>
    これは、ほとんどのモジュールで使用されている標準的な方法です。
   </para> 
   <para>
    上の例で作成された変数は、常にローカルスコープにあります。
    つまり、その関数がコールされたコンテキスト内に存在するということです。
    新しい変数をグローバルスコープに作成するにも同じメソッドを使用しますが、
    別のシンボルテーブルを参照します。
    <programlisting role="c">
<![CDATA[
zval *new_variable;
     
// 新しいコンテナを確保して初期化します
MAKE_STD_ZVAL(new_variable);

//
// 型や値をここで設定します
//

// この変数を "new_variable_name" という名前でグローバルシンボルテーブルに登録します
ZEND_SET_SYMBOL(&EG(symbol_table), "new_variable_name", new_variable);
]]>
    </programlisting>
    今回は、<literal>EG(symbol_table)</literal>
    によって参照される本体のグローバルシンボルテーブルを使用して
    <literal>ZEND_SET_SYMBOL</literal> マクロがコールされています。
   </para>
   <para>
    <emphasis>注意:</emphasis> 変数 <envar>active_symbol_table</envar>
    はポインタですが、<envar>symbol_table</envar> はそうではありません。
    これは、
    <literal>EG(active_symbol_table)</literal> および
    <literal>&amp;EG(symbol_table)</literal> を
    <literal>ZEND_SET_SYMBOL</literal> へのパラメータとして使用する必要があるからです
    - ここにはポインタが必要です。
   </para> 
   <para>
    同様に、より効率的なバージョンとして、
    シンボルテーブルの更新をハードコーディングすることもできます。
    <programlisting role="c">
<![CDATA[
zval *new_variable;

// 新しいコンテナを確保して初期化します
MAKE_STD_ZVAL(new_variable);

//
// 型や値をここで設定します
//

// この変数を "new_variable_name" という名前でグローバルシンボルテーブルに登録します
zend_hash_update(
    &EG(symbol_table),
    "new_variable_name",
    strlen("new_variable_name") + 1,
    &new_variable,
    sizeof(zval *),
    NULL
);
]]>
    </programlisting>
    <xref linkend="internals2.ze1.zendapi.example.variable-scopes"/> は、ふたつの変数を作成する例です。
    <envar>local_variable</envar> はローカルスコープ、そして
    <envar>global_variable</envar> はグローバルスコープとなります (図 9.7
    を参照ください)。完全な例は CD-ROM にあります。
   </para>
   <para>
    注意: グローバル変数は、実際には関数内からアクセスできないことにお気づきでしょう。
    これは、PHP ソース内で <literal>global $global_variable;</literal>
    のようにローカルスコープにインポートしていないからです。
   </para> 
   <example xml:id="internals2.ze1.zendapi.example.variable-scopes">
    <title>スコープが異なる変数の作成</title> 
    <programlisting role="c">
<![CDATA[
ZEND_FUNCTION(variable_creation)
{
    zval *new_var1, *new_var2;

    MAKE_STD_ZVAL(new_var1);
    MAKE_STD_ZVAL(new_var2);

    ZVAL_LONG(new_var1, 10);
    ZVAL_LONG(new_var2, 5);

    ZEND_SET_SYMBOL(EG(active_symbol_table), "local_variable", new_var1);
    ZEND_SET_SYMBOL(&EG(symbol_table), "global_variable", new_var2);

    RETURN_NULL();

}
]]>
    </programlisting>
    <mediaobject>
     <alt>スコープが異なる変数の作成</alt>
     <imageobject>
      <imagedata fileref="en/internals2/ze1/zendapi/figures/zend.06-variable-creation.png"/>
     </imageobject>
    </mediaobject>
   </example> 
  </sect3> 

  <sect3 xml:id="internals2.ze1.zendapi.variables.long"> 
   <title>Long (整数型)</title> 
   <para>
    さあ、それではデータを変数に代入していきましょう。まずは long
    型からです。long は PHP の整数型で、非常にシンプルな形式で保存されます。
    この章の最初のほうで説明した <envar>zval.value</envar> コンテナの
    構造を見てみましょう。long 型のデータは、共用体の
    <envar>lval</envar> フィールドに直接格納されることがおわかりでしょう。
    long 型に対応する <envar>type</envar> の値は
    <literal>IS_LONG</literal> です
    (<xref linkend="internals2.ze1.zendapi.example.create-long"/> を参照ください)。
    <example xml:id="internals2.ze1.zendapi.example.create-long"> 
     <title>long の作成</title> 
     <programlisting role="c">
<![CDATA[
zval *new_long;

MAKE_STD_ZVAL(new_long);

new_long-&gt;type = IS_LONG;
new_long-&gt;value.lval = 10;
]]>
     </programlisting> 
    </example>
    あるいは、マクロ <literal>ZVAL_LONG</literal> を使用することもできます。
    <programlisting role="c">
<![CDATA[
zval *new_long;

MAKE_STD_ZVAL(new_long);
ZVAL_LONG(new_long, 10);
]]>
    </programlisting>
   </para> 
  </sect3> 

  <sect3 xml:id="internals2.ze1.zendapi.variables.float"> 
   <title>Double (浮動小数点型)</title> 
   <para>
    double 型は PHP の浮動小数点型で、long 型と同様に簡単に代入できます。
    この値もまた共用体に直接格納されるからです。
    <envar>zval.value</envar> コンテナで対応するメンバは
    <envar>dval</envar> です。また、対応する type は
    <literal>IS_DOUBLE</literal> となります。
    <programlisting role="c">
<![CDATA[
zval *new_double;

MAKE_STD_ZVAL(new_double);

new_double-&gt;type = IS_DOUBLE;
new_double-&gt;value.dval = 3.45;
]]>
    </programlisting>
    あるいは、マクロ <literal>ZVAL_DOUBLE</literal> を使用することもできます。
    <programlisting role="c">
<![CDATA[
zval *new_double;

MAKE_STD_ZVAL(new_double);
ZVAL_DOUBLE(new_double, 3.45);
]]>
    </programlisting>
   </para> 
  </sect3> 

  <sect3 xml:id="internals2.ze1.zendapi.variables.string"> 
   <title>文字列</title> 
   <para>
    文字列についてはもう少し手間を掛けなければなりません。
    先に説明したように、Zend の内部データ構造に関連付けられる
    すべての文字列は、Zend 自身のメモリ管理関数を使用して管理しなければなりません。
    静的な文字列を参照したり、標準関数を使用して割り当てた文字列を使用することはできません。
    文字列を代入するには、<envar>zval.value</envar> コンテナの構造体
    <envar>str</envar> にアクセスしなければなりません。
    対応する type は <literal>IS_STRING</literal> です。
    <programlisting role="c">
<![CDATA[
zval *new_string;
char *string_contents = "This is a new string variable";

MAKE_STD_ZVAL(new_string);

new_string-&gt;type = IS_STRING;
new_string-&gt;value.str.len = strlen(string_contents);
new_string-&gt;value.str.val = estrdup(string_contents);
]]>
    </programlisting>
    ここでの、Zend の <function>estrdup</function> の使用法に注意しましょう。
    もちろん、定義済みのマクロ <literal>ZVAL_STRING</literal> を使用することも可能です。
    <programlisting>
<![CDATA[
zval *new_string;
char *string_contents = "This is a new string variable";

MAKE_STD_ZVAL(new_string);
ZVAL_STRING(new_string, string_contents, 1);
]]>
    </programlisting>
    <literal>ZVAL_STRING</literal> は、3 番目のパラメータをとることができます。
    これは、指定した文字列が (<function>estrdup</function> を使用して)
    複製されるべきかどうかを指定します。このパラメータに
    <literal>1</literal> を指定すると、文字列が複製されます。
    <literal>0</literal> の場合は、渡されたポインタを
    そのまま変数の内容として使用します。これは、すでに Zend
    の内部メモリに割り当てられている文字列を参照する変数を
    作成する場合に便利です。
   </para> 
   <para>
    ある場所で文字列を切り捨てたい場合、
    あるいは文字列の長さが事前にわかっている場合は、<literal>ZVAL_STRINGL(zval,
     string, length, duplicate)</literal> を使用して
    新しい文字列の長さを明示的に指定することができます。
    このマクロは <literal>ZVAL_STRING</literal> より高速に動作し、
    バイナリセーフです。
   </para> 
   <para>
    空の文字列を作成するには、文字列の長さを <literal>0</literal>
    にしたうえで、中身に <literal>empty_string</literal> を使用します。
    <programlisting role="c">
<![CDATA[
new_string-&gt;type = IS_STRING;
new_string-&gt;value.str.len = 0;
new_string-&gt;value.str.val = empty_string;
]]>
    </programlisting>
    もちろん、これを行うためのマクロもあります
    (<literal>ZVAL_EMPTY_STRING</literal>)。
    <programlisting role="c">
<![CDATA[
MAKE_STD_ZVAL(new_string);
ZVAL_EMPTY_STRING(new_string);
]]>
    </programlisting>
   </para> 
  </sect3> 

  <sect3 xml:id="internals2.ze1.zendapi.variables.boolean"> 
   <title>論理型</title> 
   <para>
    論理型の作り方は long 型と同じです。ただ、type は
    <literal>IS_BOOL</literal> となります。
    <envar>lval</envar> に指定できる値は
    <literal>0</literal> および <literal>1</literal> です。
    <programlisting role="c">
<![CDATA[
zval *new_bool;

MAKE_STD_ZVAL(new_bool);

new_bool-&gt;type = IS_BOOL;
new_bool-&gt;value.lval = 1;
]]>
    </programlisting>
    この型に対応するマクロは <literal>ZVAL_BOOL</literal>
    (値を指定できます)、そして <literal>ZVAL_TRUE</literal>
    および <literal>ZVAL_FALSE</literal> (それぞれ、値を明示的に
    <literal>TRUE</literal> および <literal>FALSE</literal>
    に設定します) です。
   </para> 
  </sect3> 

  <sect3 xml:id="internals2.ze1.zendapi.variables.array"> 
   <title>配列</title> 
   <para>
    配列は、Zend の内部ハッシュテーブルに格納されます。
    このハッシュテーブルにアクセスするには <function>zend_hash_*</function>
    API を使用します。配列を作成するたびに、新しいハッシュテーブルの
    ハンドルが必要となります。これは、<envar>zval.value</envar>
    コンテナのメンバ <envar>ht</envar> に格納されます。
   </para> 
   <para>
    単に配列を作成するためだけの API があります。これは非常に便利です。
    新しい配列を開始するには、<function>array_init</function>
    をコールします。
    <programlisting role="c">
<![CDATA[
zval *new_array;

MAKE_STD_ZVAL(new_array);

array_init(new_array);
]]>
     </programlisting>
    <function>array_init</function> は、常に <literal>SUCCESS</literal>
    を返します。
   </para> 
   <para>
    配列に新しい要素を追加するには、
    やりたいことに応じてさまざまな関数を使用できます。
    <xref linkend="internals2.ze1.zendapi.tab.api-assoc-arrays"/>、
    <xref linkend="internals2.ze1.zendapi.tab.api-indexed-arrays"/> および
    <xref linkend="internals2.ze1.zendapi.tab.api-indexed-array-2"/>
    で、これらの関数について説明しています。これらの関数はすべて、
    失敗した場合に <literal>FAILURE</literal>、
    成功した場合に <literal>SUCCESS</literal> を返します。
   </para>
   <table xml:id="internals2.ze1.zendapi.tab.api-assoc-arrays">
    <title>連想配列用の Zend の API</title>
<!--
    <programlisting>
Note: The functions in this table all operate on the array "array" with the key "key". 
The key string doesn't have to reside in Zend internal memory; it will be duplicated by the API.
    </programlisting>
-->
     <tgroup cols="2">
      <colspec colnum="1" colname="col1" colwidth="*"/>
      <colspec colnum="2" colname="col2" colwidth="*"/> 
      <tbody> 
       <row> 
        <entry colname="col1">関数</entry> 
        <entry colname="col2">説明</entry> 
       </row> 
       <row> 
        <entry colname="col1">
         <function>add_assoc_long(zval *array, char *key, long n);</function>
        </entry> 
        <entry colname="col2"><literal>long</literal> 型の要素を追加します。</entry> 
       </row> 
       <row> 
        <entry colname="col1">
         <function>add_assoc_unset(zval *array, char *key);</function></entry> 
        <entry colname="col2">未設定の要素を追加します。</entry> 
       </row> 
       <row> 
        <entry colname="col1">
         <function>add_assoc_bool(zval *array, char *key, int b);</function>
        </entry> 
        <entry colname="col2">Boolean 要素を追加します。</entry> 
       </row> 
       <row> 
        <entry colname="col1">
         <function>add_assoc_resource(zval *array, char *key, int r);</function>
        </entry> 
        <entry colname="col2">リソースを配列に追加します。</entry> 
       </row> 
       <row> 
        <entry colname="col1">
         <function>add_assoc_double(zval *array, char *key, double d);</function>
        </entry> 
        <entry colname="col2">浮動小数点値を追加します。</entry> 
       </row> 
       <row> 
        <entry colname="col1">
         <function>add_assoc_string(zval *array, char *key, char *str, int duplicate);</function>
        </entry> 
        <entry colname="col2">
         文字列を配列に追加します。フラグ <envar>duplicate</envar> は、
         文字列の内容を Zend の内部メモリにコピーする必要があるかどうかを指定します。
        </entry> 
       </row> 
       <row> 
        <entry colname="col1">
         <function>
          add_assoc_stringl(zval *array, char *key, char *str, uint length, int duplicate);
         </function>
        </entry> 
        <entry colname="col2">
         長さ <envar>length</envar> の文字列を配列に追加します。
         それ以外は <function>add_assoc_string</function> と同じです。
        </entry> 
       </row> 
       <row>
        <entry colname="col1"><function>add_assoc_zval(zval *array, char *key, zval *value);</function></entry>
        <entry colname="col2">zval を配列に追加します。別の配列やオブジェクト、ストリームなどを追加する際に便利です。</entry>
       </row>
      </tbody> 
     </tgroup> 
   </table> 
   <table xml:id="internals2.ze1.zendapi.tab.api-indexed-arrays">
    <title>数値添字配列用の Zend の API その 1</title> 
<!--
    <programlisting>
Note: The functions in this table all operate on the array "array" with the index "idx".
The index is always an integer.
    </programlisting> 
-->
     <tgroup cols="2">
      <colspec colnum="1" colname="col1" colwidth="*"/>
      <colspec colnum="2" colname="col2" colwidth="*"/> 
      <tbody> 
       <row> 
        <entry colname="col1">関数</entry> 
        <entry colname="col2">説明</entry> 
       </row> 
       <row> 
        <entry colname="col1"><function>add_index_long(zval *array, uint idx, long
          n);</function></entry> 
        <entry colname="col2"><literal>long</literal> 型の要素を追加します。</entry> 
       </row> 
       <row> 
        <entry colname="col1"><function>add_index_unset(zval *array, uint
          idx);</function></entry> 
        <entry colname="col2">未設定の要素を追加します。</entry> 
       </row> 
       <row> 
        <entry colname="col1"><function>add_index_bool(zval *array, uint idx, int
          b);</function></entry> 
        <entry colname="col2">Boolean 要素を追加します。</entry> 
       </row> 
       <row> 
        <entry colname="col1"><function>add_index_resource(zval *array, uint idx, int
          r);</function></entry> 
        <entry colname="col2">リソースを配列に追加します。</entry> 
       </row> 
       <row> 
        <entry colname="col1"><function>add_index_double(zval *array, uint idx, double
          d);</function></entry> 
        <entry colname="col2">浮動小数点値を追加します。</entry> 
       </row> 
       <row> 
        <entry colname="col1"><function>add_index_string(zval *array, uint idx, char
          *str, int duplicate);</function></entry> 
        <entry colname="col2">
         文字列を配列に追加します。フラグ <envar>duplicate</envar> は、
         文字列の内容を Zend の内部メモリにコピーする必要があるかどうかを指定します。
        </entry> 
       </row> 
       <row> 
        <entry colname="col1"><function>add_index_stringl(zval *array, uint idx, char
          *str, uint length, int duplicate);</function></entry> 
        <entry colname="col2">
         長さ <envar>length</envar> の文字列を配列に追加します。
         この関数は高速でバイナリセーフです。
         それ以外は <function>add_index_string</function> と同じです。
        </entry> 
       </row> 
       <row>
        <entry colname="col1"><function>add_index_zval(zval *array, uint idx, zval *value);</function></entry>
        <entry colname="col2">zval を配列に追加します。別の配列やオブジェクト、ストリームなどを追加する際に便利です。</entry>
       </row>
      </tbody> 
     </tgroup> 
   </table> 
   <table xml:id="internals2.ze1.zendapi.tab.api-indexed-array-2">
    <title>数値添字配列用の Zend の API その 2</title> 
<!--
    <programlisting>
Note: The functions in this table all operate on the array "array".
These functions automatically generate a new index based on the highest index found in the array.
    </programlisting> 
-->
     <tgroup cols="2">
      <colspec colnum="1" colname="col1" colwidth="*"/>
      <colspec colnum="2" colname="col2" colwidth="*"/> 
      <tbody> 
       <row> 
        <entry colname="col1">関数</entry> 
        <entry colname="col2">説明</entry> 
       </row> 
       <row> 
        <entry colname="col1"><function>add_next_index_long(zval *array, long
          n);</function></entry> 
        <entry colname="col2"><literal>long</literal> 型の要素を追加します。</entry> 
       </row> 
       <row> 
        <entry colname="col1"><function>add_next_index_unset(zval
          *array);</function></entry> 
        <entry colname="col2">未設定の要素を追加します。</entry> 
       </row> 
       <row> 
        <entry colname="col1"><function>add_next_index_bool(zval *array, int
          b);</function></entry> 
        <entry colname="col2">Boolean 要素を追加します。</entry> 
       </row> 
       <row> 
        <entry colname="col1"><function>add_next_index_resource(zval *array, int
          r);</function></entry> 
        <entry colname="col2">リソースを配列に追加します。</entry> 
       </row> 
       <row> 
        <entry colname="col1"><function>add_next_index_double(zval *array, double
          d);</function></entry> 
        <entry colname="col2">浮動小数点値を追加します。</entry> 
       </row> 
       <row> 
        <entry colname="col1"><function>add_next_index_string(zval *array, char *str,
          int duplicate);</function></entry> 
        <entry colname="col2">
         文字列を配列に追加します。フラグ <envar>duplicate</envar> は、
         文字列の内容を Zend の内部メモリにコピーする必要があるかどうかを指定します。
        </entry> 
       </row> 
       <row> 
        <entry colname="col1"><function>add_next_index_stringl(zval *array, char *str,
          uint length, int duplicate);</function></entry> 
        <entry colname="col2">
         長さ <envar>length</envar> の文字列を配列に追加します。
         この関数は高速でバイナリセーフです。
         それ以外は <function>add_index_string</function> と同じです。
        </entry> 
       </row> 
       <row>
        <entry colname="col1"><function>add_next_index_zval(zval *array, zval *value);</function></entry>
        <entry colname="col2">zval を配列に追加します。別の配列やオブジェクト、ストリームなどを追加する際に便利です。</entry>
       </row>
      </tbody> 
     </tgroup> 
   </table> 
   <para>
    これらの関数はすべて、Zend 内部のハッシュ API を抽象化して使用しやすくしたものです。
    もちろん、ハッシュ関数を直接使用することも可能です。例えば、すでに割り当て済みの
    <envar>zval</envar> コンテナを配列に挿入する場合などが考えられます。
    これを行うには、連想配列の場合は <function>zend_hash_update</function>
    (<xref linkend="internals2.ze1.zendapi.example.array-add-assoc"/> を参照ください)、
    数値添字配列の場合は <function>zend_hash_index_update</function>
    (<xref linkend="internals2.ze1.zendapi.example.array-add-indexed"/> を参照ください)
    を使用します。
    <example xml:id="internals2.ze1.zendapi.example.array-add-assoc">
     <title>連想配列への要素の追加</title> 
     <programlisting role="c">
<![CDATA[
zval *new_array, *new_element;
char *key = "element_key";
      
MAKE_STD_ZVAL(new_array);
MAKE_STD_ZVAL(new_element);

array_init(new_array);

ZVAL_LONG(new_element, 10);

if(zend_hash_update(new_array-&gt;value.ht, key, strlen(key) + 1, (void *)&new_element, sizeof(zval *), NULL) == FAILURE)
{
    // エラー処理をここで行います
}
]]>
     </programlisting> 
    </example> 
    <example xml:id="internals2.ze1.zendapi.example.array-add-indexed">
     <title>数値添字配列への要素の追加</title> 
     <programlisting role="c">
<![CDATA[
zval *new_array, *new_element;
int key = 2;

MAKE_STD_ZVAL(new_array);
MAKE_STD_ZVAL(new_element);

array_init(new_array);

ZVAL_LONG(new_element, 10);

if(zend_hash_index_update(new_array-&gt;value.ht, key, (void *)&new_element, sizeof(zval *), NULL) == FAILURE)
{
    // エラー処理をここで行います
}
]]>
     </programlisting> 
    </example>
   </para> 
   <para>
    <function>add_next_index_*</function> の機能をエミュレートするには、
    これを使用します。
   </para>
   <programlisting role="c">
<![CDATA[
zend_hash_next_index_insert(ht, zval **new_element, sizeof(zval *), NULL)
]]>
   </programlisting> 
   <para>
    <emphasis>注意:</emphasis> 関数から配列を返すには、まず
    <function>array_init</function> を使用し、それ以降の操作は定義済み変数
    <envar>return_value</envar> で行います
    (エクスポートする関数への引数として渡します。
    呼び出しインターフェイスについての先ほどの議論を参照ください)。
    ここで <literal>MAKE_STD_ZVAL</literal> を使用してはいけません。
   </para> 
   <para>
    <emphasis>Tip:</emphasis> 毎回
    <literal>new_array-&gt;value.ht</literal> を書く手間を省くためには
    <literal>HASH_OF(new_array)</literal> を使用します。
    これは、互換性やコーディングスタイルの観点からもお勧めです。
   </para> 
  </sect3> 

  <sect3 xml:id="internals2.ze1.zendapi.variables.object"> 
   <title>オブジェクト</title> 
   <para>
    オブジェクトは配列に変換できる (その逆も可能) ので、
    PHP の配列と多くの共通点があるであろうことはお気づきでしょう。
    オブジェクトを処理するには、同じようなハッシュ関数を使用しますが、
    オブジェクトを作成する際には異なる API を使用します。
   </para> 
   <para>
    オブジェクトを初期化するには、関数
    <function>object_init</function> を使用します。
    <programlisting role="c">
<![CDATA[
zval *new_object;

MAKE_STD_ZVAL(new_object);

if(object_init(new_object) != SUCCESS)
{
    // エラー処理をここで行います
}
]]>
    </programlisting>
    <xref linkend="internals2.ze1.zendapi.tab.object-creation"/>
    で説明している関数を使用すると、
    オブジェクトにメンバを追加することができます。
   </para> 
   <table xml:id="internals2.ze1.zendapi.tab.object-creation">
    <title>オブジェクトを作成するための Zend の API</title> 
<!--
   <programlisting>
     Note: All functions in this table work on the object "object" with the key "key". The key forms the member name,
     so the resulting member can be accessed via $object-&gt;key.
    </programlisting> 
-->
     <tgroup cols="2">
      <colspec colnum="1" colname="col1" colwidth="1.24*"/>
      <colspec colnum="2" colname="col2" colwidth="1.00*"/> 
      <tbody> 
       <row> 
        <entry colname="col1">関数</entry> 
        <entry colname="col2">説明</entry> 
       </row> 
       <row> 
        <entry colname="col1"><function>add_property_long(zval *object, char *key, long
          l);</function></entry> 
        <entry colname="col2">long 型をオブジェクトに追加します。</entry> 
       </row> 
       <row> 
        <entry colname="col1"><function>add_property_unset(zval *object, char
          *key);</function></entry> 
        <entry colname="col2">未設定のプロパティをオブジェクトに追加します。</entry> 
       </row> 
       <row> 
        <entry colname="col1"><function>add_property_bool(zval *object, char *key, int
          b);</function></entry> 
        <entry colname="col2">Boolean をオブジェクトに追加します。</entry> 
       </row> 
       <row> 
        <entry colname="col1"><function>add_property_resource(zval *object, char *key,
          long r);</function></entry> 
        <entry colname="col2">リソースをオブジェクトに追加します。</entry> 
       </row> 
       <row> 
        <entry colname="col1"><function>add_property_double(zval *object, char *key,
          double d);</function></entry> 
        <entry colname="col2">double 型をオブジェクトに追加します。</entry> 
       </row> 
       <row> 
        <entry colname="col1"><function>add_property_string(zval *object, char *key,
          char *str, int duplicate);</function></entry> 
        <entry colname="col2">文字列をオブジェクトに追加します。</entry> 
       </row> 
       <row> 
        <entry colname="col1"><function>add_property_stringl(zval *object, char *key,
          char *str, uint length, int duplicate);</function></entry> 
        <entry colname="col2">
         指定した長さの文字列をオブジェクトに追加します。この関数は
         <function>add_property_string</function> より高速で、バイナリセーフです。
        </entry> 
       </row> 

       <row>
        <entry colname="col1">
         <function>add_property_zval(zval *obect, char *key, zval *container):</function>
        </entry>
        <entry colname="col2">
         <literal>zval</literal> コンテナをオブジェクトに追加します。
         これは、整数値や文字列のような単純なものではなく
         配列やその他のオブジェクトなどをプロパティとして追加する際に有用です。
        </entry>
       </row>

      </tbody> 
     </tgroup> 
   </table> 
  </sect3> 
  
  <sect3 xml:id="zend.variables.resource">
   <title>リソース</title>
   <para>
    リソースは、PHP における特殊なデータ型です。
    <emphasis>リソース (resources)</emphasis> は何らかの特定の型を表すわけではなく、
    さまざまな情報を扱うための抽象化した方法を表しています。
    リソースは、Zend の内部では特別なリストの中に保持されます。
    リストの各エントリは、そのリソースが指すデータを表す型定義を持っています。
    Zend は、内部でリソースを扱う際には、常にこれを使用します。
    リソースに直接アクセスすることはできず、提供されている API
    を通じてアクセスしなければなりません。特定のリソースに対する
    参照がすべて失われると、対応するシャットダウン関数がすぐにコールされます。
   </para>
   <para>
    例えば、リソースは、
    データベースへのリンクやファイル記述子を格納するために使用されます。
    <emphasis>事実上の</emphasis>標準実装となっているのは
    MySQL モジュールです。しかし、例えば Oracle モジュールのような
    その他のモジュールでもリソースを使用しています。
    <note>
     <para>
      実際のところ、あなたが関数内で処理したい任意のデータへのポインタ
      (例: 構造体へのポインタ) を、リソースとして使用することができます。
      ユーザーがこのデータにアクセスするには、ひとつのリソース変数を
      関数に渡すだけでいいようになります。
     </para>
    </note>
   </para>
   <para>
    新しいリソースを作成するには、そのリソースを開放するためのハンドラを
    登録しなければなりません。リソースにはあらゆる種類のデータを保存できるので、
    Zend は、それが不要になった際にどのように開放するのかを知っておく必要があるのです。
    これを実現するために、自分が作成したリソース開放ハンドラを Zend
    に登録します。これは、(手動・自動にかかわらず)
    リソースを開放することになった際に、Zend によってコールされます。
    リソースハンドラを Zend に登録すると、そのリソースについての
    <emphasis role="strong">リソース型ハンドル</emphasis>が Zend から返されます。
    このハンドルは、後でこの型のリソースにアクセスする際には常に必要となり、
    たいていは拡張モジュール内のグローバルな静的変数として保存されます。
    スレッドセーフであるかどうかについて心配する必要はありません。
    なぜなら、リソースハンドラの登録は
    モジュールの初期化時に一度行うだけだからです。
   </para>
   <para>
    リソースハンドラを登録するための Zend の関数は、次のように宣言されています。
    <programlisting role="c">
<![CDATA[
ZEND_API int zend_register_list_destructors_ex(rsrc_dtor_func_t ld, rsrc_dtor_func_t pld, char *type_name, int module_number);
]]>
    </programlisting>
   </para>
   <para>
    この関数には、二種類の異なるリソース破壊ハンドラを渡すことが可能です。
    それぞれ、通常のリソース用のものと持続的なリソース用のものになります。
    持続的なリソースとは、例えばデータベース接続などに使用されるものです。
    リソースを登録する際には、これらのどちらかのハンドラを必ず指定しなければなりません。
    もう一方のほうには、単に <literal>NULL</literal> を渡すようにします。
   </para>
   <para>
    <function>zend_register_list_destructors_ex</function>
    は、次のパラメータを受け取ります。
    <informaltable>
     <tgroup cols="2">
      <colspec colnum="1" colname="col1" colwidth="1.00*"/>
      <colspec colnum="2" colname="col2" colwidth="5.00*"/>
      <tbody>
       <row>
        <entry colname="col1"><literal>ld</literal></entry>
        <entry colname="col2">
         通常のリソース用のリソース破壊ハンドラコールバック。
        </entry>
       </row>
       <row>
        <entry colname="col1"><literal>pld</literal></entry>
        <entry colname="col2">
         持続的なリソース用のリソース破壊ハンドラコールバック。
        </entry>
       </row>
       <row>
        <entry colname="col1"><literal>type_name</literal></entry>
        <entry colname="col2">
         そのリソースの名前を表す文字列。
         PHP 内で一意になるような名前をつけるよう心がけましょう。
         ユーザーが例えば <literal>var_dump($resource);</literal>
         をコールした際に、この名前が表示されます。
        </entry>
       </row>
       <row>
        <entry colname="col1"><literal>module_number</literal></entry>
        <entry colname="col2">
         <literal>module_number</literal> は、
         <literal>PHP_MINIT_FUNCTION</literal>
         関数の中で自動的に使用可能となります。
         そのため、単純にそれを渡すだけです。
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
    返り値は、作成した
    <emphasis role="strong">リソース型</emphasis>
    の一意な ID となる整数値です。
   </para>
   <para>
    リソース破壊ハンドラ (通常版および持続的リソース版のどちらも)
    のプロトタイプは次のようになります。
    <programlisting>void resource_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC);</programlisting>
    <literal>rsrc</literal> に渡されるのは、次のような構造体へのポインタです。
    <programlisting role="c">
<![CDATA[
typedef struct _zend_rsrc_list_entry {
     
    void *ptr;
    int type;
    int refcount;

} zend_rsrc_list_entry;
]]>
    </programlisting>
    メンバ <literal>void *ptr</literal> が、
    リソースへの実際のポインタとなります。
   </para>
   <para>
    これでやるべきことがわかりました。Zend に登録したいリソースを、
    実際に定義してみましょう。
    ここでは、ふたつの整数型メンバからなる単純な構造体を考えます。
    <programlisting role="c">
<![CDATA[
typedef struct {
     
    int resource_link;
    int resource_type;

} my_resource;
]]>
    </programlisting>
    このリソースを破壊するハンドラは、おそらく次のようなものとなるでしょう。
    <programlisting role="c">
<![CDATA[
void my_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) {

    // たいていは void ポインタを構造体の型にキャストすることになるでしょう。

    my_resource *my_rsrc = (my_resource *) rsrc->ptr;

    // ここで、そのリソースに対して必要な作業を行います。たとえば
    // ファイルやソケットを閉じたり、内部で新たに確保したメモリを開放したりなどです。
    // もちろん、このリソース自身が使っているメモリを開放することも忘れないようにしましょう。

    do_whatever_needs_to_be_done_with_the_resource(my_rsrc);
}
]]>
    </programlisting>
    <note>
     <para>
      注意すべき点: もしそのリソースが複雑な構造体であり、
      その内部で実行時に確保したメモリへのポインタを含んでいる場合は、
      リソース自身のメモリを開放する
      <emphasis role="strong">前に</emphasis>
      実行時に確保したメモリを開放しなければなりません。
     </para>
    </note>
   </para>
   <para>
    ここまでで、
    <orderedlist>
     <listitem><para>どんなリソースなのか</para></listitem>
     <listitem><para>そのリソースを破壊する際のハンドラ</para></listitem>
    </orderedlist>
    の定義が終了しました。それでは残りの作業を進めましょう。
    <orderedlist>
     <listitem><para>拡張モジュール内のグローバル変数を作成し、
       リソース ID を保持させる。必要に応じて、
       これは全ての関数からアクセス可能となる</para></listitem>
     <listitem><para>リソース名を定義する</para></listitem>
     <listitem><para>リソース破壊ハンドラを記述する</para></listitem>
     <listitem><para>そしてそのハンドラを登録する</para></listitem>
    </orderedlist>
    <programlisting role="c">
<![CDATA[
    // 拡張モジュール内のどこかで、登録したリソース用の変数を定義します。
    // 'le' って何のことだって? 単に 'list entry' を略しただけです。
    static int le_myresource;

    // リソース名もどこかで定義しておくとよいでしょう。
    #define le_myresource_name  "My type of resource"

    [...]

    // 実際にリソース破壊ハンドラを登録します。
    void my_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) {

        my_resource *my_rsrc = (my_resource *) rsrc->ptr;
        do_whatever_needs_to_be_done_with_the_resource(my_rsrc);
    }

    [...]

    PHP_MINIT_FUNCTION(my_extension) {

        // 'module_number' は、PHP_MINIT_FUNCTION() 関数の
        // 定義で既に提供されていることに注意しましょう。

        le_myresource = zend_register_list_destructors_ex(my_destruction_handler, NULL, le_myresource_name, module_number);

        // 別のリソースを登録したり、グローバル変数や定数を
        // 初期化したりします。
    }
]]>
    </programlisting>
   </para>
   <para>
    実際に新しいリソースを登録するには、
    <function>zend_register_resource</function> 関数あるいは
    <function>ZEND_REGISTER_RESOURE</function> マクロのいずれかを使用します。
    これらはどちらも zend_list.h で定義されています。
    それぞれの引数は一対一対応しているので、
    将来の互換性を考えると常にマクロを使用するようにすることをお勧めします。
    <programlisting role="c">
<![CDATA[
int ZEND_REGISTER_RESOURCE(zval *rsrc_result, void *rsrc_pointer, int rsrc_type);
]]>
    </programlisting>
    <informaltable>
     <tgroup cols="2">
      <colspec colnum="1" colname="col1" colwidth="1.00*"/>
      <colspec colnum="2" colname="col2" colwidth="5.00*"/>
      <tbody>
       <row>
        <entry colname="col1"><literal>rsrc_result</literal></entry>
        <entry colname="col2">これは、事前に初期化済みの
         <literal>zval *</literal> コンテナです。</entry>
       </row>
       <row>
        <entry colname="col1"><literal>rsrc_pointer</literal></entry>
        <entry colname="col2">保存したいリソースへのポインタ。</entry>
       </row>
       <row>
        <entry colname="col1"><literal>rsrc_type</literal></entry>
        <entry colname="col2">
         リソース破壊ハンドラを登録した際に受け取る型。
         命名規約に従うなら、これは
         <literal>le_myresource</literal> となります。
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
    返り値は、そのリソースに対応する一意な整数値になります。
   </para>
   <para>
    新しいリソースを登録する際に実際には何が行われているのかというと、
    まずそれが Zend の内部リストに挿入されます。そして、
    結果は単に与えられた <literal>zval *</literal>
    コンテナに保存されます。
    <programlisting role="c">
<![CDATA[
    rsrc_id = zend_list_insert(rsrc_pointer, rsrc_type);
     
    if (rsrc_result) {
        rsrc_result->value.lval = rsrc_id;
        rsrc_result->type = IS_RESOURCE;
    }

    return rsrc_id;
]]>
    </programlisting>
    返される <literal>rsrc_id</literal> は、
    新しく登録されたリソースを表す一意な識別子となります。
    マクロ <literal>RETURN_RESOURE</literal> を使用して、
    これを利用者に返すことができます。
    <programlisting>    RETURN_RESOURCE(rsrc_id)</programlisting>
    <note>
     <para>
      そのリソースをすぐに利用者に返したいのなら、
      <literal>return_value</literal> を
      <literal>zval *</literal> コンテナに設定するのが一般的な方法です。
     </para>
    </note>
   </para>
   <para>
    Zend はこれ以降、このリソースに対するすべての参照を管理できるようになります。
    リソースへの参照がすべて失われると、リソースに対して事前に定義した
    デストラクタがすぐにコールされます。この設定の利点は、
    あなたのモジュール内で発生するメモリリークを気にしなくてもすむということです。
    呼び出し元スクリプトで割り当てているすべてのメモリはリソースを参照しています。
    メモリが必要なくなったとスクリプトが判断した時点で、
    Zend はすぐにそれを検出して通知してくれます。
   </para>
   <para>
    さて、利用者がリソースを取得したあとで、
    それをまたあなたの作成した関数に渡してきたとしましょう。
    <literal>zval *</literal> コンテナ内の
    <envar>value.lval</envar> にはあなたのリソースのキーが含まれているので、
    それを使用して次のマクロでリソースを取得することができます。
    <literal>ZEND_FETCH_RESOURCE</literal>:
    <programlisting role="c">
<![CDATA[
ZEND_FETCH_RESOURCE(rsrc, rsrc_type, rsrc_id, default_rsrc_id, resource_type_name, resource_type)
]]>
        </programlisting>
    <informaltable>
     <tgroup cols="2">
      <colspec colnum="1" colname="col1" colwidth="1.00*"/>
      <colspec colnum="2" colname="col2" colwidth="5.00*"/>
      <tbody>
       <row>
        <entry colname="col1"><literal>rsrc</literal></entry>
        <entry colname="col2">
         これは、あなたが事前に登録したリソースを指すポインタです。
        </entry>
       </row>
       <row>
        <entry colname="col1"><literal>rsrc_type</literal></entry>
        <entry colname="col2">
         これは、ポインタに対する型キャスト引数、例えば
         <literal>myresource *</literal> などです。
        </entry>
       </row>
       <row>
        <entry colname="col1"><literal>rsrc_id</literal></entry>
        <entry colname="col2">
         これは、利用者があなたの関数に渡した
         <literal>zval *</literal> コンテナのアドレスです。例えば
         <literal>zval *z_resource</literal> が指定された場合には
         <literal>&amp;z_resource</literal> となります。
        </entry>
       </row>
       <row>
        <entry colname="col1"><literal>default_rsrc_id</literal></entry>
        <entry colname="col2">
         これは、リソースが取得できなかった場合は -1 が返された場合などのための
         デフォルトのリソース <literal>ID</literal> です。
        </entry>
       </row>
       <row>
        <entry colname="col1"><literal>resource_type_name</literal></entry>
        <entry colname="col2">
         これは、要求されたリソースの名前です。
         リソースが見つからなかった場合や無効なリソースだった場合に、
         意味のあるエラーメッセージを作成するためにこの文字列を使用します。
        </entry>
       </row>
       <row>
        <entry colname="col1"><literal>resource_type</literal></entry>
        <entry colname="col2">
         リソース破壊ハンドラを登録した際に返すリソース型です。
         今回の例では、これは <envar>le_myresource</envar> でした。
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
    このマクロは何も値を返しません。これは開発者の利便性のためで、
    TSRMLS 引数のことを考慮したものです。リソースを読み込む段階でチェックが行われます。
    リソースの取得時にエラーが発生した場合は、このマクロは
    警告メッセージをスローし、PHP 関数は <literal>NULL</literal>
    を返します。
   </para>
   <para>
    リソースをリストから強制的に削除するには、関数
    <function>zend_list_delete</function> を使用します。
    また事前に割り当てた値への新たな参照を作成した場合
    (例えば、デフォルトのデータベースリンクを再利用する場合)
    などは、強制的に参照カウンタを増加させることができます。
    このような場合は、関数 <function>zend_list_addref</function>
    を使用します。事前に割り当てたリソースエントリを探すには
    <function>zend_list_find</function> を使用します。
    これらの完全な API は、<filename>zend_list.h</filename>
    で確認できます。
   </para>
  </sect3>

  <sect3 xml:id="internals2.ze1.zendapi.variables.global"> 
   <title>自動グローバル変数の作成のためのマクロ</title> 
   <para>
    先ほど説明したマクロに加え、
    単純なグローバル変数を簡単に作成するためのマクロがあります。
    これらは、例えばグローバルなフラグなどを作成する際に知っておくと便利です。
    あまり行儀のよいやり方ではありませんが、
    <xref linkend="internals2.ze1.zendapi.tab.macros-global-vars"/>
    で説明するマクロはまさにこの作業を行うためのものです。
    これらは <envar>zval</envar> を確保する必要がありません。
    単純に、変数名と値を渡すだけでいいのです。
   </para> 
   <table xml:id="internals2.ze1.zendapi.tab.macros-global-vars">
    <title>グローバル変数の作成のためのマクロ</title>
<!--    
 <programlisting>
     Note: All macros in this table create a global variable of the name "name" with the value "value".
    </programlisting> 
-->
     <tgroup cols="2">
      <colspec colnum="1" colname="col1" colwidth="*"/>
      <colspec colnum="2" colname="col2" colwidth="*"/> 
      <tbody> 
       <row> 
        <entry colname="col1">マクロ</entry> 
        <entry colname="col2">説明</entry> 
       </row> 
       <row> 
        <entry colname="col1"><literal>SET_VAR_STRING(name, value)</literal></entry> 
        <entry colname="col2">新しい文字列を作成します。</entry> 
       </row> 
       <row> 
        <entry colname="col1"><literal>SET_VAR_STRINGL(name, value,
          length)</literal></entry> 
        <entry colname="col2">
         新しい文字列を、指定した長さで作成します。このマクロは
         <literal>SET_VAR_STRING</literal> より高速で、バイナリセーフです。
        </entry> 
       </row> 
       <row> 
        <entry colname="col1"><literal>SET_VAR_LONG(name, value)</literal></entry> 
        <entry colname="col2">新しい long を作成します。</entry> 
       </row> 
       <row> 
        <entry colname="col1"><literal>SET_VAR_DOUBLE(name, value)</literal></entry> 
        <entry colname="col2">新しい double を作成します。</entry> 
       </row> 
      </tbody> 
     </tgroup> 
   </table> 
  </sect3> 

  <sect3 xml:id="internals2.ze1.zendapi.variables.constant">
   <title>定数の作成</title> 
   <para>
    Zend は (通常の変数ではなく) 真の定数の作成もサポートしています。
    定数へのアクセスにはドル記号 (<literal>$</literal>)
    の接頭辞が不要で、すべてのスコープで使用可能です。
    例としては <literal>TRUE</literal> や
    <literal>FALSE</literal> などがあります。
   </para> 
   <para>
    独自の定数を作成するには、
    <xref linkend="internals2.ze1.zendapi.tab.create-const"/> のマクロを使用します。
    これらのマクロは、指定した名前と値の定数を作成します。
   </para>
   <para>
    各定数に対して、フラグを指定することもできます。
    <itemizedlist> 
     <listitem> 
      <para>
       <literal>CONST_CS</literal> -
       この定数名は、大文字小文字を区別して扱われます。
      </para> 
     </listitem> 
     <listitem> 
      <para>
       <literal>CONST_PERSISTENT</literal> -
       この定数は持続的に扱われ、この定数を保持しているプロセスが
       終了した後も「忘れられる」ことはありません。
      </para> 
     </listitem> 
    </itemizedlist>
    これらのフラグは、OR で組み合わせて使用します。
    <programlisting> // "long" 型の新しい定数を登録します。
     REGISTER_LONG_CONSTANT("NEW_MEANINGFUL_CONSTANT", 324, CONST_CS |
     CONST_PERSISTENT); </programlisting>
    マクロには、ふたつの形式があります。
    <literal>REGISTER_*_CONSTANT</literal> および
    <literal>REGISTER_MAIN_*_CONSTANT</literal> です。
    最初の形式は、定数を現在のモジュールにバインドします。
    これらの定数は、そのモジュールがメモリから開放されるとすぐに、
    シンボルテーブルから削除されます。二番目の形式が作成する定数は、
    モジュールとは独立してシンボルテーブルに残り続けます。
   </para> 
   <table xml:id="internals2.ze1.zendapi.tab.create-const">
    <title>定数を作成するためのマクロ</title> 
     <tgroup cols="2">
      <colspec colnum="1" colname="col1" colwidth="1.53*"/>
      <colspec colnum="2" colname="col2" colwidth="1.00*"/> 
      <tbody> 
       <row> 
        <entry colname="col1">マクロ</entry> 
        <entry colname="col2">説明</entry> 
       </row> 
       <row> 
        <entry colname="col1"> 
         <literal>REGISTER_LONG_CONSTANT(name, value, flags)</literal>
         <literal>REGISTER_MAIN_LONG_CONSTANT(name, value, flags)</literal>
        </entry> 
        <entry colname="col2">long 型の新しい定数を登録します。</entry> 
       </row> 
       <row> 
        <entry colname="col1"> 
         <literal>REGISTER_DOUBLE_CONSTANT(name, value, flags)</literal>
         <literal>REGISTER_MAIN_DOUBLE_CONSTANT(name, value, flags)</literal>
        </entry> 
        <entry colname="col2">double 型の新しい定数を登録します。</entry> 
       </row> 
       <row> 
        <entry colname="col1"> 
         <literal>REGISTER_STRING_CONSTANT(name, value, flags)</literal>
         <literal>REGISTER_MAIN_STRING_CONSTANT(name, value, flags)</literal>
        </entry> 
        <entry colname="col2">
         文字列型の新しい定数を登録します。指定した文字列は、Zend
         の内部メモリ上に存在しなければなりません。
        </entry> 
       </row> 
       <row> 
        <entry colname="col1"> 
         <literal>REGISTER_STRINGL_CONSTANT(name, value, length, flags)</literal> 
         <literal>REGISTER_MAIN_STRINGL_CONSTANT(name, value, length,
          flags)</literal>
        </entry> 
        <entry colname="col2">
         文字列型の新しい定数を登録します。文字列の長さを、
         明示的に <envar>length</envar> と指定します。
         指定した文字列は、Zend の内部メモリ上に存在しなければなりません。
        </entry> 
       </row> 
      </tbody> 
     </tgroup> 
   </table> 
  </sect3>
 </sect2>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
