<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 337361 Maintainer: takagi Status: ready -->
<!-- CREDITS: hirokawa -->
 <chapter xml:id="language.operators" xmlns="http://docbook.org/ns/docbook">
  <title>演算子</title>
  <simpara>
   演算子とは、ひとつ以上の値 (あるいはプログラミング用語における「式」)
   から別の値 (制御構造が式になるように) を生み出すものです。
  </simpara>
  <para>
   演算子は、受け取る値の数によって分類することができます。単項演算子はひとつの値だけを受け取るもので、
   <literal>!</literal> (
   <link linkend="language.operators.logical">論理否定演算子</link>) や
   <literal>++</literal> (
   <link linkend="language.operators.increment">加算子</link>)
   などです。二項演算子はふたつの値を受け取ります。おなじみの
   <link linkend="language.operators.arithmetic">代数演算子</link> である
   <literal>+</literal> (加算) や <literal>-</literal> (減算)
   など PHP の演算子の大半はこの分類に含まれます。最後は三つの値を受け取る
   <link linkend="language.operators.comparison.ternary">三項演算子</link>
   で、これは <literal>? :</literal> だけしかありません。この演算子はしばしば、単に
   "三項演算子" と呼ばれます (しかし、より適切な呼び方としては
   条件演算子と呼ぶほうがよいでしょう)。
  </para>
  <para>
   PHP の演算子の完全な一覧は、
   <link linkend="language.operators.precedence">演算子の優先順位</link>
   の欄にあります。この節では演算子の優先順位と結合性について説明します。
   複数の演算子を組み合わせたときにどう評価されるのかは、優先順位と結合性で決まります。
  </para>

  <sect1 xml:id="language.operators.precedence">
   <title>演算子の優先順位</title>
   <para>
    演算子の優先順位は、二つの式が"緊密に"結合している度合いを指定します。
    例えば、式 <literal>1 + 5 * 3</literal> の答えは
    <literal>16</literal> になり、<literal>18</literal> とはなりません。
    これは乗算演算子("*")は、加算演算子("+")より高い優先順位を有するか
    らです。必要に応じて強制的に優先順位を設定するために括弧を使用する
    ことが可能です。例えば、<literal>18</literal>と評価するためには、
    <literal>(1 + 5) * 3</literal> とします。
   </para>
   <para>
    演算子の優先順位が等しい場合は、その結合性によって評価順
    (右から評価するのか、あるいは左から評価するのか) が決まります。
    たとえば "-" は左結合なので、
    <literal>1 - 2 - 3</literal> は <literal>(1 - 2) - 3</literal> とグループ分けされて、
    評価結果は <literal>-4</literal> になります。
    一方、"=" は右結合です。つまり <literal>$a = $b = $c</literal> のグループ分けは
    <literal>$a = ($b = $c)</literal> となります。
   </para>
   <para>
    優先順位が同じで結合しない演算子を並べることはできません。つまり、たとえば
    <literal>1 &lt; 2 &gt; 1</literal> は PHP では無効になります。
    一方 <literal>1 &lt;= 1 == 1</literal> は問題ありません。
    <literal>==</literal> 演算子の優先順位が
    <literal>&lt;=</literal> 演算子より低いからです。
   </para>
   <para>
    厳密には不要な場所であっても、括弧をつけておけばコードの可読性があがります。
    明示的にグループ分けをしておくことで、演算子の優先順位や結合性による暗黙のグループ分けに頼らずに済むからです。
   </para>
   <para>
    次の表では、優先順位が高い順に演算子を挙げています。
    同じ行にある演算子は優先順位が等しくなります。そのような場合は、
    結合時の評価にしたがってグループ分けが決まります。
    <table>
     <title>演算子の優先順位</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>結合時の評価</entry>
        <entry>演算子</entry>
        <entry>追加情報</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>結合しない</entry>
        <entry>
         <literal>clone</literal>
         <literal>new</literal>
        </entry>
        <entry><link linkend="language.oop5.cloning">clone</link> および <link linkend="language.oop5.basic.new">new</link></entry>
       </row>
       <row>
        <entry>left</entry>
        <entry><literal>[</literal></entry>
        <entry><function>array</function></entry>
       </row>
       <row>
        <entry>right</entry>
        <entry><literal>**</literal></entry>
        <entry><link linkend="language.operators.arithmetic">代数演算子</link></entry>
       </row>
       <row>
        <entry>right</entry>
        <entry>
         <literal>++</literal> 
         <literal>--</literal> 
         <literal>~</literal> 
         <literal>(int)</literal> 
         <literal>(float)</literal> 
         <literal>(string)</literal> 
         <literal>(array)</literal>
         <literal>(object)</literal> 
         <literal>(bool)</literal> 
         <literal>@</literal>
        </entry>
        <entry>
         <link linkend="language.types">型</link> および <link linkend="language.operators.increment">加算子/減算子</link>
        </entry>
       </row>
       <row>
        <entry>結合しない</entry>
        <entry><literal>instanceof</literal></entry>
        <entry>
         <link linkend="language.types">型</link>
        </entry>
       </row>
       <row>
        <entry>right</entry>
        <entry><literal>!</literal></entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>
         <literal>*</literal>
         <literal>/</literal>
         <literal>%</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">代数演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>
         <literal>+</literal> 
         <literal>-</literal> 
         <literal>.</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">代数演算子</link>&listendand; 
         <link linkend="language.operators.string">文字列演算子</link></entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>
         <literal>&lt;&lt;</literal> 
         <literal>&gt;&gt;</literal>
        </entry>
        <entry>
         <link linkend="language.operators.bitwise">ビット演算子</link>
        </entry>
       </row>
       <row>
        <entry>結合しない</entry>
        <entry>
         <literal>&lt;</literal> 
         <literal>&lt;=</literal> 
         <literal>&gt;</literal> 
         <literal>&gt;=</literal>
        </entry>
        <entry>
         <link linkend="language.operators.comparison">比較演算子</link>
        </entry>
       </row>
       <row>
        <entry>結合しない</entry>
        <entry>
         <literal>==</literal>
         <literal>!=</literal> 
         <literal>===</literal> 
         <literal>!==</literal> 
         <literal>&lt;&gt;</literal>
        </entry>
        <entry>
         <link linkend="language.operators.comparison">比較演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry><literal>&amp;</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">ビット演算子</link>&listendand; 
         <link linkend="language.references">リファレンス</link></entry>
       </row>
       <row>
        <entry>left</entry>
        <entry><literal>^</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">ビット演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry><literal>|</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">ビット演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry><literal>&amp;&amp;</literal></entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry><literal>||</literal></entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry><literal>? :</literal></entry>
        <entry>
         <link linkend="language.operators.comparison.ternary">三項演算子</link>
        </entry>
       </row>
       <row>
        <entry>right</entry>
        <entry>
         <literal>=</literal> 
         <literal>+=</literal> 
         <literal>-=</literal> 
         <literal>*=</literal> 
         <literal>**=</literal> 
         <literal>/=</literal> 
         <literal>.=</literal> 
         <literal>%=</literal> 
         <literal>&amp;=</literal> 
         <literal>|=</literal> 
         <literal>^=</literal> 
         <literal>&lt;&lt;=</literal> 
         <literal>&gt;&gt;=</literal>
         <literal>=&gt;</literal>
        </entry>
        <entry>
         <link linkend="language.operators.assignment">代入演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry><literal>and</literal></entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry><literal>xor</literal></entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry><literal>or</literal></entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry><literal>,</literal></entry>
        <entry>さまざまな利用法</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    <example>
     <title>結合時の評価</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    演算子の優先順位や結合性は、あくまでも式のグループ分けだけを決めるものであり、評価順を決めるものではありません。
    PHP では一般に、式をどの順番で評価するかは決めていませｎ。
    そのため、特定の順序で式が評価されることを前提としたコードを書いてはいけません。
    PHP のバージョンが変わったり前後のコードが変わったりしたときに、評価順が変わる可能性があるからです。
    <example>
     <title>評価順序は未定義</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
echo $a + $a++; // 1 になるかもしれないし、2 になるかもしれません

$i = 1;
$array[$i] = $i++; // インデックス 1 をセットするかもしれないし、インデックス 2 をセットするかもしれません
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     <literal>=</literal> は他のほとんどの演算子よりも優先順位が低いはずなのにもかかわらず、
     PHP は依然として <literal>if (!$a = foo())</literal>
     のような式も許します。この場合は <literal>foo()</literal> の返り値が
     <varname>$a</varname> に代入されます。
    </para>
   </note>
  </sect1>
  
  <sect1 xml:id="language.operators.arithmetic">
   <title>代数演算子</title>
   <simpara>
    学校で習った基礎代数を憶えていますか?
    この演算子はそれらと同様に動作します。
   </simpara>
   <table>
    <title>代数演算子</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>-$a</entry>
       <entry>負にする</entry>
       <entry><varname>$a</varname> の逆</entry>
      </row>
      <row>
       <entry>$a + $b</entry>
       <entry>加算</entry>
       <entry><varname>$a</varname> および <varname>$b</varname> の合計</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>減算</entry>
       <entry><varname>$a</varname> と <varname>$b</varname> の差</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>乗算</entry>
        <entry><varname>$a</varname> および <varname>$b</varname> の積</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>除算</entry>
        <entry><varname>$a</varname> および <varname>$b</varname> の商</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>剰余</entry>
       <entry><varname>$a</varname> を <varname>$b</varname> で割った余り</entry>
      </row>
      <row>
       <entry>$a ** $b</entry>
       <entry>累乗</entry>
       <entry><varname>$a</varname> の <varname>$b</varname> 乗。PHP 5.6 で導入されました。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  
   <simpara>
    除算演算子 ("/") の返す値は浮動小数点数となります。
    ただし、ふたつのオペランドがともに整数 (あるいは整数に変換できる文字列)
    であり、かつ結果が割り切れる場合には整数値を返します。
   </simpara>
   <simpara>
    剰余演算子は、まず両方のオペランドを整数に直し
    (小数点以下を切り捨てます)
    てから処理を行います。
   </simpara>
   <para>
    剰余演算子 <literal>%</literal> の結果の符号は、被除数の符号と同じになります。
    つまり、<literal>$a % $b</literal> の結果の符号は
    <varname>$a</varname> と同じになるということです。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

echo (5 % 3)."\n";           // 2
echo (5 % -3)."\n";          // 2
echo (-5 % 3)."\n";          // -2
echo (-5 % -3)."\n";         // -2

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    マニュアルの
    <link linkend="ref.math">数学関数</link>の項も参照してください。
   </simpara>

  </sect1>

  <sect1 xml:id="language.operators.assignment">
   <title>代入演算子</title>
   <simpara>
    代入演算子の基本となるものは "=" です。この演算子に関して最初に
    思い付く意味は"等しい"であるかもしれません。しかし、そうではありません。
    本当は、左オペランドに右オペランドの式の値を設定する("得て代入する")
    ことを意味します。
   </simpara>
   <para>
    代入式の値は、代入される値です。つまり、"<literal>$a = 3</literal>" の値は、3 です。
    これにより、以下のようなトリッキーなことができるようになります。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = ($b = 4) + 5; // $a は 9 に等しくなり、$b には 4 が代入されます

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    配列の場合、キーの名前を指定して値を代入するには "=&gt;"
    演算子を使います。この演算子の <link linkend="language.operators.precedence">優先順位</link>
    は、その他の代入演算子と同じです。
   </para>
   <para>
    基本代入演算子に加えて、全ての<link linkend="language.operators">
    バイナリ演算子</link>、配列結合および文字列演算子に関して
    「複合演算子」があります。
    これにより、式の中の値を使用し、その値をその式の結果とすることができます。
    例えば、
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = 3;
$a += 5; // $a を 8 にセットします。$a = $a + 5; と同じです。
$b = "Hello ";
$b .= "There!"; // $bを"Hello There!"にセットします。$b = $b . "There!";と同じです。

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    代入は、元の変数を新しい変数にコピーする(値による代入)ため、
    片方の変数に対する変更はもう片方に影響を与えないということに
    注意してください。この動作により、密なループの内側で大きな配列のようなものを
    コピーする必要がある場合には問題を生じる可能性があります。
   </para>
   <para>
    PHP では通常は値による代入になりますが、オブジェクト型については例外です。
    PHP 5 以降、オブジェクトは参照で代入されるようになりました。オブジェクトを明示的にコピーするには
    <link linkend="language.oop5.cloning">clone</link> キーワードを使います。
   </para>

   <sect2 xml:id="language.operators.assignment.reference">
    <title>参照による代入</title>
    <para>
     参照による代入もサポートしており、
     "<computeroutput>$var = &amp;$othervar;</computeroutput>" 構文で使うことができます。
     参照による代入とは、両方の変数が同じデータを指すようにするということです。
     データのコピーは発生しません。
    </para>
    <para>
     <example>
      <title>参照による代入</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 3;
$b = &$a; // $b は $a への参照です

print "$a\n"; // 表示: 3
print "$b\n"; // 表示: 3

$a = 4; // change $a

print "$a\n"; // 表示: 4
print "$b\n"; // 表示: 4
              // $b の参照先は $a であり、その値が変わったからです
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     PHP 5 以降では、<link linkend="language.oop5.basic.new">new</link>
     演算子が自動的に参照を返すようになりました。そのため、
     <link linkend="language.oop5.basic.new">new</link> の結果を参照で代入しようとすると
     PHP 5.3 以降では <constant>E_DEPRECATED</constant>、それより前のバージョンでは 
     <constant>E_STRICT</constant> が発生します。
    </para>
    <para>
     たとえば、このコードは警告が発生します。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

/* 次の行を実行すると、このようなエラーメッセージが出ます
 * Deprecated: Assigning the return value of new by reference is deprecated in...
 */
$o = &new C;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     参照に関する詳細な情報やその使い方については、このマニュアルの
     <link linkend="language.references">参照に関する説明</link>
     をご覧ください。
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.bitwise">
   <title>ビット演算子</title>
   <simpara>
    ビット演算子は、整数値の特定のビットの評価や操作を行います。
   </simpara>
   <table>
    <title>ビット演算子</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><userinput>$a &amp; $b</userinput></entry>
       <entry>ビット積</entry>
       <entry><varname>$a</varname> および <varname>$b</varname> の両方にセットされているビットがセットされます</entry>
      </row>
      <row>
       <entry><userinput>$a | $b</userinput></entry>
       <entry>ビット和</entry>
       <entry><varname>$a</varname> または <varname>$b</varname> のどちらかにセットされているビットがセットされます</entry>
      </row>
      <row>
       <entry><userinput>$a ^ $b</userinput></entry>
       <entry>排他的論理和</entry>
       <entry><varname>$a</varname> または <varname>$b</varname> のどちらか一方にセットされており、両方にセットされていないビットがセットされます</entry>
      </row>
      <row>
       <entry><userinput>~ $a</userinput></entry>
       <entry>否定</entry>
       <entry><varname>$a</varname> にセットされているビットはセットせず、そうでないものは逆にします</entry>
      </row>
      <row>
       <entry><userinput>$a &lt;&lt; $b</userinput></entry>
       <entry>左シフト</entry>
       <entry><varname>$a</varname> のビットを左に <varname>$b</varname> ビットシフトする (各シフトは "2をかける"
    ことを意味します)
       </entry>
      </row>
      <row>
       <entry><userinput>$a &gt;&gt; $b</userinput></entry>
       <entry>右シフト</entry>
       <entry><varname>$a</varname> のビットを右に <varname>$b</varname> ビットシフトします (各シフトは "2で割る"
    ことを意味します)
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    PHP のシフト処理は算術シフトです。両端からあふれたビットは捨てられます。
    左シフトをすると右側にはゼロが埋められます。
    符号ビットは左端からあふれて消えます。
    つまり、オペランドの符号は維持されないということです。
    右シフトの際には、符号ビットと同じ内容が左端から埋められます。
    つまり、この場合はオペランドの符号が維持されます。
   </para>
   <para>
    括弧を使うことで、望みどおりの
    <link linkend="language.operators.precedence">優先順位</link>
    で処理させることができます。たとえば、<literal>$a &amp; $b == true</literal>
    はまず等価かどうかを評価してからビット演算を行いますが
    <literal>($a &amp; $b) == true</literal>
    はまずビット演算を行ってから等価かどうかを評価します。
   </para>
   <para>
    <literal>&amp;</literal>、<literal>|</literal> そして
    <literal>^</literal> 演算子の左右のオペランドが文字列の場合、その演算は、
    文字列を構成する文字の ASCII 値を使って行います。その結果は文字列になります。
    それ以外の場合は、左右のオペランドを
    <link linkend="language.types.integer.casting">integer に変換</link>
    し、結果も integer になります。
   </para>
   <para>
    <literal>~</literal> 演算子のオペランドが文字列の場合、その演算は、
    文字列を構成する文字の ASCII 値を使って行います。その結果は文字列になります。
    それ以外の場合は、オペランドや演算結果を integer として扱います。
   </para>
   <para>
    <literal>&lt;&lt;</literal> および
    <literal>&gt;&gt;</literal> 演算子のオペランドとその結果は、常に integer として扱います。
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
PHP の ini 設定 error_reporting はビット値を用いています。
これを用いて、特定のビットを落とす演算の例を見てみましょう。
notice 以外のすべてのエラーを表示させるには、
php.ini ファイルで
<userinput>E_ALL &amp; ~E_NOTICE</userinput>
と指定することになります。
      </literallayout>
     </para>
     <para>
      <literallayout>
まずは E_ALL。
<computeroutput>00000000000000000111011111111111</computeroutput>
そして E_NOTICE...。
<computeroutput>00000000000000000000000000001000</computeroutput>
... これを <literal>~</literal> で逆転させます。
<computeroutput>11111111111111111111111111110111</computeroutput>
最後に AND (&amp;) を使い、両方ともビットが立っているところをみつけます。
<computeroutput>00000000000000000111011111110111</computeroutput>
      </literallayout>
     </para>
     <para>
      <literallayout>
同じ結果を得るもうひとつの方法として、 XOR (<literal>^</literal>)
を使ってどちらか一方だけ立っているビットを探すという方法もあります。
<userinput>E_ALL ^ E_NOTICE</userinput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
error_reporting を使って、特定のビットを立てる処理の例を見てみましょう。
通常のエラーとリカバー可能なエラーだけを表示させるには、次のようにします。
<userinput>E_ERROR | E_RECOVERABLE_ERROR</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
この処理は、 E_ERROR
<computeroutput>00000000000000000000000000000001</computeroutput>
と
<computeroutput>00000000000000000001000000000000</computeroutput>
を OR (<literal>|</literal>) 演算子でつないで、
少なくともどちらかのビットが立っているところを取得します。
<computeroutput>00000000000000000001000000000001</computeroutput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <example>
     <title>整数値におけるビット AND、OR および XOR 演算</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * このへんは無視してください。
 * たんに結果をきれいに表示させるためだけのものです。
 */

$format = '(%1$2d = %1$04b) = (%2$2d = %2$04b)'
        . ' %3$s (%4$2d = %4$04b)' . "\n";

echo <<<EOH
 ---------     ---------  -- ---------
 result        value      op test
 ---------     ---------  -- ---------
EOH;


/*
 * ここからが本番
 */

$values = array(0, 1, 2, 4, 8);
$test = 1 + 4;

echo "\n Bitwise AND \n";
foreach ($values as $value) {
    $result = $value & $test;
    printf($format, $result, $value, '&', $test);
}

echo "\n Bitwise Inclusive OR \n";
foreach ($values as $value) {
    $result = $value | $test;
    printf($format, $result, $value, '|', $test);
}

echo "\n Bitwise Exclusive OR (XOR) \n";
foreach ($values as $value) {
    $result = $value ^ $test;
    printf($format, $result, $value, '^', $test);
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
 ---------     ---------  -- ---------
 result        value      op test
 ---------     ---------  -- ---------
 Bitwise AND
( 0 = 0000) = ( 0 = 0000) & ( 5 = 0101)
( 1 = 0001) = ( 1 = 0001) & ( 5 = 0101)
( 0 = 0000) = ( 2 = 0010) & ( 5 = 0101)
( 4 = 0100) = ( 4 = 0100) & ( 5 = 0101)
( 0 = 0000) = ( 8 = 1000) & ( 5 = 0101)

 Bitwise Inclusive OR
( 5 = 0101) = ( 0 = 0000) | ( 5 = 0101)
( 5 = 0101) = ( 1 = 0001) | ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) | ( 5 = 0101)
( 5 = 0101) = ( 4 = 0100) | ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) | ( 5 = 0101)

 Bitwise Exclusive OR (XOR)
( 5 = 0101) = ( 0 = 0000) ^ ( 5 = 0101)
( 4 = 0100) = ( 1 = 0001) ^ ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)
( 1 = 0001) = ( 4 = 0100) ^ ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) ^ ( 5 = 0101)
]]>
     </screen>
    </example>
   </para>
   <para>
    <example>
     <title>文字列でのビット XOR 演算</title>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // 出力は '5'

echo "12" ^ "9"; // 出力はバックスペース文字 (ascii 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // 出力は、ascii コード #0 #4 #0 #0 #0
                        // 'a' ^ 'e' = #4

echo 2 ^ "3"; // 出力は 1
              // 2 ^ ((int)"3") == 1

echo "2" ^ 3; // 出力は 1
              // ((int)"2") ^ 3 == 1
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>整数値のビットシフト</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * これが例です
 */

echo "\n--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---\n";

$val = 4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'copy of sign bit shifted into left side');

$val = 4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places);

$val = 4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'bits shift out right side');

$val = 4;
$places = 4;
$res = $val >> $places;
p($res, $val, '>>', $places, 'same result as above; can not shift beyond 0');


echo "\n--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---\n";

$val = -4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'copy of sign bit shifted into left side');

$val = -4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places, 'bits shift out right side');

$val = -4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'same result as above; can not shift beyond -1');


echo "\n--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---\n";

$val = 4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'zeros fill in right side');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 4;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = 4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places, 'sign bits get shifted out');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'bits shift out left side');


echo "\n--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---\n";

$val = -4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'zeros fill in right side');

$val = -4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = -4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'bits shift out left side, including sign bit');


/*
 * このへんは無視してください。
 * たんに結果をきれいに表示させるためだけのものです。
 */

function p($res, $val, $op, $places, $note = '') {
    $format = '%0' . (PHP_INT_SIZE * 8) . "b\n";

    printf("Expression: %d = %d %s %d\n", $res, $val, $op, $places);

    echo " Decimal:\n";
    printf("  val=%d\n", $val);
    printf("  res=%d\n", $res);

    echo " Binary:\n";
    printf('  val=' . $format, $val);
    printf('  res=' . $format, $res);

    if ($note) {
        echo " NOTE: $note\n";
    }

    echo "\n";
}
?>
]]>
     </programlisting>
     &example.outputs.32bit;
     <screen>
<![CDATA[

--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---
Expression: 2 = 4 >> 1
 Decimal:
  val=4
  res=2
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000010
 NOTE: copy of sign bit shifted into left side

Expression: 1 = 4 >> 2
 Decimal:
  val=4
  res=1
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000001

Expression: 0 = 4 >> 3
 Decimal:
  val=4
  res=0
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTE: bits shift out right side

Expression: 0 = 4 >> 4
 Decimal:
  val=4
  res=0
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTE: same result as above; can not shift beyond 0


--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---
Expression: -2 = -4 >> 1
 Decimal:
  val=-4
  res=-2
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111110
 NOTE: copy of sign bit shifted into left side

Expression: -1 = -4 >> 2
 Decimal:
  val=-4
  res=-1
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTE: bits shift out right side

Expression: -1 = -4 >> 3
 Decimal:
  val=-4
  res=-1
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTE: same result as above; can not shift beyond -1


--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---
Expression: 8 = 4 << 1
 Decimal:
  val=4
  res=8
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000001000
 NOTE: zeros fill in right side

Expression: 1073741824 = 4 << 28
 Decimal:
  val=4
  res=1073741824
 Binary:
  val=00000000000000000000000000000100
  res=01000000000000000000000000000000

Expression: -2147483648 = 4 << 29
 Decimal:
  val=4
  res=-2147483648
 Binary:
  val=00000000000000000000000000000100
  res=10000000000000000000000000000000
 NOTE: sign bits get shifted out

Expression: 0 = 4 << 30
 Decimal:
  val=4
  res=0
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTE: bits shift out left side


--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---
Expression: -8 = -4 << 1
 Decimal:
  val=-4
  res=-8
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111000
 NOTE: zeros fill in right side

Expression: -2147483648 = -4 << 29
 Decimal:
  val=-4
  res=-2147483648
 Binary:
  val=11111111111111111111111111111100
  res=10000000000000000000000000000000

Expression: 0 = -4 << 30
 Decimal:
  val=-4
  res=0
 Binary:
  val=11111111111111111111111111111100
  res=00000000000000000000000000000000
 NOTE: bits shift out left side, including sign bit
]]>
     </screen>
     &example.outputs.64bit;
     <screen>
<![CDATA[

--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---
Expression: 2 = 4 >> 1
 Decimal:
  val=4
  res=2
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000010
 NOTE: copy of sign bit shifted into left side

Expression: 1 = 4 >> 2
 Decimal:
  val=4
  res=1
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000001

Expression: 0 = 4 >> 3
 Decimal:
  val=4
  res=0
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: bits shift out right side

Expression: 0 = 4 >> 4
 Decimal:
  val=4
  res=0
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: same result as above; can not shift beyond 0


--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---
Expression: -2 = -4 >> 1
 Decimal:
  val=-4
  res=-2
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111110
 NOTE: copy of sign bit shifted into left side

Expression: -1 = -4 >> 2
 Decimal:
  val=-4
  res=-1
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTE: bits shift out right side

Expression: -1 = -4 >> 3
 Decimal:
  val=-4
  res=-1
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTE: same result as above; can not shift beyond -1


--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---
Expression: 8 = 4 << 1
 Decimal:
  val=4
  res=8
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000001000
 NOTE: zeros fill in right side

Expression: 4611686018427387904 = 4 << 60
 Decimal:
  val=4
  res=4611686018427387904
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0100000000000000000000000000000000000000000000000000000000000000

Expression: -9223372036854775808 = 4 << 61
 Decimal:
  val=4
  res=-9223372036854775808
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=1000000000000000000000000000000000000000000000000000000000000000
 NOTE: sign bits get shifted out

Expression: 0 = 4 << 62
 Decimal:
  val=4
  res=0
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: bits shift out left side


--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---
Expression: -8 = -4 << 1
 Decimal:
  val=-4
  res=-8
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111000
 NOTE: zeros fill in right side

Expression: -9223372036854775808 = -4 << 61
 Decimal:
  val=-4
  res=-9223372036854775808
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1000000000000000000000000000000000000000000000000000000000000000

Expression: 0 = -4 << 62
 Decimal:
  val=-4
  res=0
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: bits shift out left side, including sign bit
]]>
     </screen>
    </example>
   </para>
   <warning>
    <para>
     システムの long 型で扱える範囲以上の整数値をシフトした場合の結果は未定義です。
     32ビットシステム上では、32ビット以上の値をシフトしないようにしましょう。
     同様に、64ビットシステム上では、64ビット以上の値をシフトしないようにしましょう。
    </para>
    <para>
     <literal>PHP_INT_MAX</literal> を超える数のビット演算には、
     <link linkend="book.gmp">gmp</link> 拡張モジュールの関数を使いましょう。
    </para>
   </warning>
   <para>
    <function>pack</function>,
    <function>unpack</function>,
    <function>gmp_and</function>,
    <function>gmp_or</function>,
    <function>gmp_xor</function>,
    <function>gmp_testbit</function>,
    <function>gmp_clrbit</function>
    も参照ください。
   </para>
  </sect1>

  <sect1 xml:id="language.operators.comparison">
   <title>比較演算子</title>
   <simpara>
    比較演算子は、その名前が示すように、二つの値を比較します。
    <link linkend="types.comparisons">型の比較表</link>
    に、型に関連するさまざまな比較の例があります。
   </simpara>
   <table>
    <title>比較演算子</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>等しい</entry>
       <entry>型の相互変換をした後で <varname>$a</varname> が <varname>$b</varname> に等しい時に &true;。</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>等しい</entry>
       <entry><varname>$a</varname> が <varname>$b</varname> に等しく、および同じ型である場合に &true; 。
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>等しくない</entry>
       <entry>型の相互変換をした後で <varname>$a</varname> が <varname>$b</varname> に等しくない場合に &true;。</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>等しくない</entry>
       <entry>型の相互変換をした後で <varname>$a</varname> が <varname>$b</varname> に等しくない場合に &true;。</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>等しくない</entry>
       <entry>
        <varname>$a</varname> が <varname>$b</varname> と等しくないか、同じ型でない場合に &true; 。
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>より少ない</entry>
       <entry><varname>$a</varname> が <varname>$b</varname> より少ない時に &true;。</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>より多い</entry>
       <entry><varname>$a</varname> が <varname>$b</varname> より多い時に &true;。</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>より少ないか等しい</entry>
       <entry><varname>$a</varname> が <varname>$b</varname> より少ないか等しい時に &true;。</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>より多いか等しい</entry>
       <entry><varname>$a</varname> が <varname>$b</varname> より多いか等しい時に &true;。</entry>
      </row>
      <row>
       <entry>$a &lt;=&gt; $b</entry>
       <entry>宇宙船</entry>
       <entry>
        <varname>$a</varname> が <varname>$b</varname> より小さいときに負の値、
        <varname>$b</varname> と等しいときに 0、
        <varname>$b</varname> より大きいときに正の値。
        PHP 7 以降で使用可能。
       </entry>
      </row>
      <row>
       <entry>$a ?? $b ?? $c</entry>
       <entry>Null Coalesce</entry>
       <entry>
        左から順に評価し、最初に見つかった &null; 以外の値。
        存在しない場合は &null;。
        PHP 7 以降で使用可能。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    整数値を文字列と比較したり、比較に数値形式の文字が含まれる場合は、文字列が
    <link linkend="language.types.string.conversion">数値に変換され</link>、
    数値としての比較を行います。これらのルールは、
    <link linkend="control-structures.switch">switch</link> 文にも適用されます。
    === あるいは !== による比較では型変換は発生しません。
    この場合は値だけでなく型も比較します。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump("1" == "01"); // 1 == 1 -> true
var_dump("10" == "1e1"); // 10 == 10 -> true
var_dump(100 == "1e2"); // 100 == 100 -> true

switch ("a") {
case 0:
    echo "0";
    break;
case "a": // "a" は 0 にマッチするので、決してここにはたどりつきません
    echo "a";
    break;
}
?>
]]>
     </programlisting>
     <programlisting role="php">
<![CDATA[
<?php  
// Integer
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1
 
// Float
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1
 
// 文字列
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1
 
echo "a" <=> "aa"; // -1
echo "zz" <=> "aa"; // 1
 
// 配列
echo [] <=> []; // 0
echo [1, 2, 3] <=> [1, 2, 3]; // 0
echo [1, 2, 3] <=> []; // 1
echo [1, 2, 3] <=> [1, 2, 1]; // 1
echo [1, 2, 3] <=> [1, 2, 4]; // -1
 
// オブジェクト
$a = (object) ["a" => "b"]; 
$b = (object) ["a" => "b"]; 
echo $a <=> $b; // 0
 
$a = (object) ["a" => "b"]; 
$b = (object) ["a" => "c"]; 
echo $a <=> $b; // -1
 
$a = (object) ["a" => "c"]; 
$b = (object) ["a" => "b"]; 
echo $a <=> $b; // 1
 
// 値だけを比較します
$a = (object) ["a" => "b"]; 
$b = (object) ["b" => "b"]; 
echo $a <=> $b; // 1

?>
]]>
      
     </programlisting>
    </informalexample>
   </para>

   <para>
    多くの型では、以下の表にしたがって（上から順に）比較が行われます。
   </para>
   <table xml:id="language.operators.comparison.types">
    <title>さまざまな型の比較</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>第 1 オペランドの型</entry>
       <entry>第 2 オペランドの型</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>null</type> または <type>string</type></entry>
       <entry><type>string</type></entry>
       <entry>&null; を "" に変換し、数値または文字として比較します</entry>
      </row>
      <row>
       <entry><type>bool</type> または <type>null</type></entry>
       <entry>あらゆる型</entry>
       <entry>両辺を <type>bool</type> に変換し、&false; &lt; &true; と判断します</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry><type>object</type></entry>
       <entry>組み込みクラスには独自の比較基準が定義されています。それ以外の
        クラスは比較できません。同じクラスであるかどうかは - プロパティが
        同じ値であるかどうかを配列形式で比較（PHP 4）、PHP 5 では <link
        linkend="language.oop5.object-comparison">ここで説明されています</link>。
       </entry>
      </row>
      <row>
       <entry><type>string</type>, <type>resource</type> または <type>number</type></entry>
       <entry><type>string</type>, <type>resource</type> または <type>number</type></entry>
       <entry>文字列やリソースを数値に変換し、算術演算を行います</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry><type>array</type></entry>
       <entry>要素数の少ない配列のほうが小さくなります。オペランド 1 のキーが
        オペランド 2 に存在しない場合、配列は比較できません。そうでない場合は
        個々の要素の値を比較します（以下の例を参照ください）</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry>あらゆる型</entry>
       <entry><type>object</type> のほうが常に大きくなります</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry>あらゆる型</entry>
       <entry><type>array</type> のほうが常に大きくなります</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    <example>
     <title>Boolean/null comparison</title>
     <programlisting role="php">
<![CDATA[
<?php
// Bool and null are compared as bool always
var_dump(1 == TRUE);  // TRUE - same as (bool)1 == TRUE
var_dump(0 == FALSE); // TRUE - same as (bool)0 == FALSE
var_dump(100 < TRUE); // FALSE - same as (bool)100 < TRUE
var_dump(-10 < FALSE);// FALSE - same as (bool)-10 < FALSE
var_dump(min(-100, -10, NULL, 10, 100)); // NULL - (bool)NULL < (bool)-100 is FALSE < TRUE
?>
]]>
     </programlisting>
    </example>
   </para>


   <para>
    <example>
     <title>一般的な配列の比較</title>
     <programlisting role="php">
<![CDATA[
<?php
// 標準の比較演算子を用いて、配列はこのように比較されます
function standard_array_compare($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $key => $val) {
        if (!array_key_exists($key, $op2)) {
            return null; // uncomparable
        } elseif ($val < $op2[$key]) {
            return -1;
        } elseif ($val > $op2[$key]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
]]>
     </programlisting>
    </example> 
   </para>

   <para>
    <function>strcasecmp</function>,
    <function>strcmp</function>、
    <link linkend="language.operators.array">配列演算子</link>,
    マニュアルの
    <link linkend="language.types">型</link> のセクションも参照してください。
   </para>

   <warning>
    <title>浮動小数点数値の比較</title>

    <para>
     ふたつの <type>float</type> 値が等しいかどうかを調べてはいけません。
     <type>float</type> の内部的な表現方法がその理由です。
    </para>

    <para>
     詳細な情報は <type>float</type> のドキュメントを参照ください。
    </para>
   </warning>

   <sect2 xml:id="language.operators.comparison.ternary">
    <title>三項演算子</title>
    <para>
     もうひとつの条件演算子として "?:"（あるいは三項）演算子があります。
     <example>
      <title>デフォルト値を設定する</title>
      <programlisting role="php">
<![CDATA[
<?php
// 三項演算子の使用例
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// 上記は以下の if/else 式と同じです。
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}

?>
]]>
      </programlisting>
     </example> 
     <literal>(expr1) ? (expr2) : (expr3)</literal>
     という式は、<replaceable>式1</replaceable> が &true; の場合に
     <replaceable>式2</replaceable> を、
     <replaceable>式1</replaceable> が &false; の場合に
     <replaceable>式3</replaceable> を値とします。
    </para>
    <para>
     PHP 5.3 以降では、三項演算子のまんなかの部分をなくすこともできるようになりました。
     式 <literal>expr1 ?: expr3</literal> の結果は、<replaceable>expr1</replaceable> が
     &true; と同等の場合は <replaceable>expr1</replaceable>、
     それ以外の場合は <replaceable>expr3</replaceable> となります。
    </para>
    <note>
     <simpara>
      三項演算子は式であり、値としては評価されずに式の結果として評価される
      ことに注意してください。演算結果をリファレンスとして返したい場合に、
      これを知っておくことが大切です。結果をリファレンスとして返す関数で
      <literal>return $var == 42 ? $a : $b;</literal> とすることはできず、
      新しいバージョンの PHP では警告を発生します。
     </simpara>
    </note>
    <note>
     <para>
      三項演算子を "積み重ねて" 使用することは避けましょう。
      ひとつの文の中で複数の三項演算子を使用した際の PHP の振る舞いは、
      少々わかりにくいものです。
      <example>
       <title>三項演算子のわかりにくい挙動</title>
       <programlisting role="php">
<![CDATA[
<?php
// ぱっと見た感じでは、これは 'true' と表示されると思うでしょう。
echo (true?'true':false?'t':'f');

// しかし、実際には上の出力結果は 't' です。
// なぜなら、三項演算子は左から右へ順に評価されるからです。

// 上のコードをもう少しわかりやすく書くと、このようになります。
echo ((true ? 'true' : false) ? 't' : 'f');

// まず、最初の式が 'true' と評価されます。この 'true' は
// (bool)true と評価されるので、それをもとに二番目の三項
// 演算子が評価されます。
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2>

  </sect1>
 
  <sect1 xml:id="language.operators.errorcontrol">
   <title>エラー制御演算子</title>
   <simpara>
    PHP はエラー制御演算子(@)をサポートしています。PHP の式の前に付けた場合、
    その式により生成されたエラーメッセージは無視されます。
   </simpara>
   <simpara>
    <function>set_error_handler</function> で自作のエラーハンドラを設定した場合は
    エラー制御演算子があってもそのエラーハンドラがコールされます。
    しかし、自作のエラーハンドラの中で <function>error_reporting</function>
    をコールすれば、@ つきの式で生成されたエラーの場合は返り値が 0
    になるのでこの値で区別することができます。
    自作のエラーハンドラの中ではこの方法による区別を行うべきです。
   </simpara>
   <simpara>
    <link linkend="ini.track-errors"><option>track_errors</option></link> 機能が
    有効な場合、式により生成されたエラーメッセージはグローバル変数
    <varname>$php_errormsg</varname>
    に保存されます。この変数はエラーが発生するたびに上書きされます。
    そのため、この変数を使用したい場合には速やかに確認する必要があります。
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* 意図的なエラー */
$my_file = @file ('non_existent_file') or
    die ("Failed opening file: error was '$php_errormsg'");

// この演算子は関数だけでなく、全ての式で動作します。
$value = @$cache[$key]; 
// インデックス $key が存在しない場合でも、警告を発生しません。

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     @演算子は、<link linkend="language.expressions">式</link>
     でのみ動作します。基本的なルールは次のようになります。
     値を得ることができるものの場合、@ 演算子を前に付けることが可能です。
     例えば、変数、関数、<function>include</function> コール、定数等の
     前にこの演算子をつけることが可能です。関数またはクラスの定義や
     <literal>if</literal> や &foreach; 等のような
     条件構造の前にこの演算子を付けることはできません。
    </simpara>
   </note>
   <simpara>
    <function>error_reporting</function> と、
    <link linkend="ref.errorfunc">エラー処理とログ出力関数</link>
    も参照してください。
   </simpara>
   <warning>
    <para>
     現在、エラー制御演算子プレフィックス"@"は、スクリプトの実行を
     終了するような致命的なエラーの出力さえ抑圧します。このため、ある関数の
     エラー出力を抑制するために "@" を使用した場合、その関数が
     利用できなかったり、ミスタイプがあった場合でも、原因を示すことなく
     その場所でスクリプトは終了してしまいます。
    </para>
   </warning>
  </sect1>
  
  <sect1 xml:id="language.operators.execution">
   <title>実行演算子</title>
   <para>
    PHP は 1 種類の実行演算子、バッククォート (``) をサポートします。
    シングルクォートではないことに注意してください! PHP は、バッククォートの
    中身をシェルコマンドとして実行しようとします。出力が返されます
    (すなわち、出力を単にダンプするのではなく、変数に代入することが
    できます) 。
    バッククォート演算子の使用は <function>shell_exec</function> と等価です。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     バッククォート演算子は、&safemode; が有効な場合
     もしくは <function>shell_exec</function> が無効な場合は無効となります。
    </para>
   </note>
   <note>
    <para>
     他の言語とは異なり、
     ダブルクォートで囲まれた文字列の中でのバッククォート演算子には何の効力もありません。
    </para>
   </note>
   <para>
    マニュアルの <link linkend="ref.exec">システムプログラムの実行</link>
    や <function>popen</function>,
    <function>proc_open</function>, そして
    <link linkend="features.commandline">PHPをコマンドラインから使用する</link>
    も参照してください。
   </para>
  </sect1>
   
  <sect1 xml:id="language.operators.increment">
   <title>加算子/減算子</title>
   <para>
    PHP は C 言語形式の加算子/減算子（前置・後置ともに）をサポートします。
   </para>
   <note>
    <simpara>
     加算子/減算子は、数値や文字列にしか影響を及ぼしません。
     配列やオブジェクトそしてリソースには、何も変更を加えません。
     同じく &null; に減算子を適用しても何も起こりませんが、&null; に加算子を
     適用すると <literal>1</literal> となります。
    </simpara>
   </note>
   <table>
    <title>加算子/減算子</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>効果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>前置加算子</entry>
       <entry><varname>$a</varname> に 1 を加え、<varname>$a</varname> を返します。</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>後置加算子</entry>
       <entry><varname>$a</varname> を返し、<varname>$a</varname> に1を加えます。</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>前置減算子</entry>
       <entry><varname>$a</varname> から 1 を引き、<varname>$a</varname> を返します。</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>後置減算子</entry>
       <entry><varname>$a</varname> を返し、<varname>$a</varname> から 1 を引きます。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    以下に簡単なスクリプトの例を示します。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>後置加算</h3>";
$a = 5;
echo "5 となります: " . $a++ . "<br>\n";
echo "6 となります: " . $a . "<br>\n";
 
echo "<h3>前置加算</h3>";
$a = 5;
echo "6 となります: " . ++$a . "<br>\n";
echo "6 となります: " . $a . "<br>\n";

echo "<h3>後置減算</h3>";
$a = 5;
echo "5 となります: " . $a-- . "<br>\n";
echo "4 となります: " . $a . "<br>\n";

echo "<h3>前置減算</h3>";
$a = 5;
echo "4 となります: " . --$a . "<br>\n";
echo "4 となります: " . $a . "<br>\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    PHP は、算術演算子で文字変数を扱った場合に C ではなく Perl の慣習に
    従います。例えば、PHP や Perl では <literal>$a = 'Z'; $a++;</literal>
    の結果として <literal>$a</literal> が <literal>'AA'</literal> になりますが
    C では <literal>a = 'Z'; a++;</literal> の結果として
    <literal>a</literal> は <literal>'['</literal> になります
    (<literal>'Z'</literal> の ASCII 値は 90、そして <literal>'['</literal> の ASCII 値は 91 です)。
    文字変数はインクリメントされることは可能ですがデクリメントは不可能であるということ、
    またプレーンな ASCII 文字と数字 (a-z、A-Z、そして 0-9) のみがサポートされるということに注意しましょう。
    その他の文字変数のインクリメント/デクリメントは何の効果もなく、元の文字列は変更されません。
    <example>
     <title>文字変数に対する算術演算子の使用</title>
     <programlisting role="php">
<![CDATA[
<?php
echo '== Alphabets ==' . PHP_EOL;
$s = 'W';
for ($n=0; $n<6; $n++) {
    echo ++$s . PHP_EOL;
}
// 数字の挙動は異なります
echo '== Digits ==' . PHP_EOL;
$d = 'A8';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
$d = 'A08';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
== Characters ==
X
Y
Z
AA
AB
AC
== Digits ==
A9
B0
B1
B2
B3
B4
A09
A10
A11
A12
A13
A14
]]>
     </screen>
    </example>
   </para>
   <para>
    論理型に対する加算/減算は何の影響も及ぼしません。
   </para>
  </sect1>
 
  <sect1 xml:id="language.operators.logical">
   <title>論理演算子</title>
 
   <table>
    <title>論理演算子</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>論理積</entry>
       <entry><varname>$a</varname> および <varname>$b</varname> が共に &true; の場合に &true;</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>論理和</entry>
       <entry><varname>$a</varname> または <varname>$b</varname> のどちらかが &true; の場合に &true;</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>排他的論理和</entry>
       <entry>
    <varname>$a</varname> または <varname>$b</varname> のどちらかが &true; でかつ両方とも &true; でない場合に &true;
       </entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>否定</entry>
       <entry><varname>$a</varname> が &true; でない場合 &true;</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>論理積</entry>
       <entry><varname>$a</varname> および <varname>$b</varname> が共に &true; の場合に &true;</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>論理和</entry>
       <entry><varname>$a</varname> または <varname>$b</varname> のどちらかが &true; の場合に &true;</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    "and" および "or" 演算子が 2 種類あるのは、演算が行われる際の優先順位が
    異なっているためです
    (<link linkend="language.operators.precedence">演算子の優先順位</link>
    を参照ください)。
   </simpara>
   <example>
    <title>論理演算子についての説明</title>
    <programlisting role="php">
<![CDATA[
<?php

// --------------------
// foo() は決してコールされることはありません。これらの演算子は短絡評価を行うからです。

$a = (false && foo());
$b = (true  || foo());
$c = (false and foo());
$d = (true  or  foo());

// --------------------
// "||" の優先順位は "or" より高くなります

// $e に代入されるのは、(false || true) の評価結果です
// これは、次の式と同様です: ($e = (false || true))
$e = false || true;

// $f には false が代入され、true は無視されます
// これは、次の式と同様です: (($f = false) or true)
$f = false or true;

var_dump($e, $f);

// --------------------
// "&&" の優先順位は "and" より高くなります

// $g に代入されるのは、(true && false) の評価結果です
// これは、次の式と同様です: ($g = (true && false))
$g = true && false;

// $h には true が代入され、false は無視されます
// これは、次の式と同様です: (($h = true) and false)
$h = true and false;

var_dump($g, $h);
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
bool(true)
bool(false)
bool(false)
bool(true)
]]>
    </screen>
   </example>
  </sect1>

  <sect1 xml:id="language.operators.string">
   <title>文字列演算子</title>
   <simpara>
    文字列の演算子は 2 種類あります。最初のは結合演算子('.')で、右引数と
    左引数を結合したものを返します。2 番目は、結合代入演算子('<literal>.=</literal>')で、
    この演算子は右側の引数に左側の引数を追加します。詳細は、<link
    linkend="language.operators.assignment">代入演算子</link> を
    参照ください。
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "Hello ";
$b = $a . "World!"; // $b は、"Hello World!" となります。

$a = "Hello ";
$a .= "World!"; // $a は、"Hello World!" となります。
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    <link linkend="language.types.string">文字列</link> と 
    <link linkend="ref.strings">文字列 関数</link>も参照してください。
   </para>
  </sect1>
  
  <sect1 xml:id="language.operators.array">
   <title>配列演算子</title>
   <table>
    <title>Array Operators</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>結合</entry>
       <entry><varname>$a</varname> および <varname>$b</varname> を結合する。</entry>
      </row>
      <row>
       <entry>$a == $b</entry>
       <entry>同等</entry>
       <entry><varname>$a</varname> および <varname>$b</varname> のキー/値のペアが等しい場合に &true;。</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>同一</entry>
       <entry>
        <varname>$a</varname> および <varname>$b</varname> のキー/値のペアが等しく、その並び順が等しく、
        かつデータ型も等しい場合に &true;。
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>等しくない</entry>
       <entry><varname>$a</varname> が <varname>$b</varname> と等しくない場合に &true;。</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>等しくない</entry>
       <entry><varname>$a</varname> が <varname>$b</varname> と等しくない場合に &true;。</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>同一でない</entry>
       <entry><varname>$a</varname> が <varname>$b</varname> と同一でない場合に &true;。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    <literal>+</literal> 演算子は、右側の配列を左側の配列に追加したものを返します。
    両方の配列に存在するキーについては左側の配列の要素が優先され、
    右側の配列にあった同じキーの要素は無視されます。
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "apple", "b" => "banana");
$b = array("a" => "pear", "b" => "strawberry", "c" => "cherry");

$c = $a + $b; // Union of $a and $b
echo "Union of \$a and \$b: \n";
var_dump($c);

$c = $b + $a; // Union of $b and $a
echo "Union of \$b and \$a: \n";
var_dump($c);
?>
]]>
     </programlisting>
    </informalexample>
    このスクリプトを実行すると、以下のように出力されます。
    <screen role="php">
<![CDATA[
Union of $a and $b:
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}
Union of $b and $a:
array(3) {
  ["a"]=>
  string(4) "pear"
  ["b"]=>
  string(10) "strawberry"
  ["c"]=>
  string(6) "cherry"
}
]]>
    </screen>
   </para>
   <para>
    同じキーと値を保持している場合に、配列が等しいとみなされます。
   </para>
   <para>
    <example>
     <title>配列の比較</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("apple", "banana");
$b = array(1 => "banana", "0" => "apple");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <link linkend="language.types.array">配列</link>と 
    <link linkend="ref.array">配列関数</link>も参照してください。
   </para>
  </sect1>

  <sect1 xml:id="language.operators.type">
   <title>型演算子</title>
   <para>
    <literal>instanceof</literal> を使用して、
    ある PHP 変数が特定の
    <link linkend="language.oop5.basic.class">クラス</link>
    のオブジェクトのインスタンスであるかどうかを調べます。
    <example>
     <title>クラスでの <literal>instanceof</literal> の使用法</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

class NotMyClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof NotMyClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    <literal>instanceof</literal> は、ある変数が
    特定の親クラスを継承したクラスのオブジェクトのインスタンスであるかどうかを調べることもできます。
    <example>
     <title>継承したクラスでの <literal>instanceof</literal> の使用法</title>
     <programlisting role="php">
<![CDATA[
<?php
class ParentClass
{
}

class MyClass extends ParentClass
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof ParentClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    あるオブジェクトが特定のクラスのインスタンスで <emphasis>ない</emphasis>
    ことを調べるには、
    <link linkend="language.operators.logical">論理 <literal>否定</literal> 演算子</link>
    を使用します。
    <example>
     <title><literal>instanceof</literal> を使用して、オブジェクトがクラスのインスタンスで <emphasis>ない</emphasis>
      かどうかを調べる方法</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

$a = new MyClass;
var_dump(!($a instanceof stdClass));
?>
]]>
     </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    最後に、<literal>instanceof</literal>
    は、ある変数が特定の
    <link linkend="language.oop5.interfaces">インターフェイス</link>
    を実装したクラスのオブジェクトのインスタンスであるかどうかも調べることができます。
    <example>
     <title>クラスでの <literal>instanceof</literal> の使用法</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof MyInterface);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    通常、<literal>instanceof</literal> ではリテラルのクラス名を使用しますが、
    別のオブジェクトや文字列変数を使用することもできます。
    <example>
     <title>変数を用いた <literal>instanceof</literal> の使用法</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;
$b = new MyClass;
$c = 'MyClass';
$d = 'NotMyClass';

var_dump($a instanceof $b); // $b MyClass クラスのオブジェクトです
var_dump($a instanceof $c); // $c は文字列 'MyClass' です
var_dump($a instanceof $d); // $d は文字列 'NotMyClass' です
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    instanceof は、もし確かめる変数がオブジェクトでなくてもエラーになりません。単に
    &false; を返すだけです。ただし、定数を調べることはできません。
    <example>
     <title><literal>instanceof</literal> での他の変数の調べかた</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = NULL;
$c = imagecreate(5, 5);
var_dump($a instanceof stdClass); // $a は配列です
var_dump($b instanceof stdClass); // $b は NULL です
var_dump($c instanceof stdClass); // $c はリソースです
var_dump(FALSE instanceof stdClass);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
bool(false)
bool(false)
PHP Fatal error:  instanceof expects an object instance, constant given
]]>
     </screen>
    </example>
   </para>
   <para>
    注意すべき落とし穴があります。PHP 5.1.0 より前のバージョンでは、
    <literal>instanceof</literal> は、クラス名が存在しない場合に
    <function>__autoload</function> をコールしていました。
    さらに、クラスが読み込めなかった場合に致命的なエラーが発生していました。
    この問題の回避策としては、動的なクラス参照を使用するか、
    クラス名を含む文字列変数を使用します。
    <example>
     <title>PHP 5.0 における、クラス名検索時の致命的エラーの回避策</title>
     <programlisting role="php">
<![CDATA[
<?php
$d = 'NotMyClass';
var_dump($a instanceof $d); // これで、致命的なエラーは発生しません
?>
     ]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
]]>
     </screen>
    </example>
   </para>
   <simpara>
    <literal>instanceof</literal> 演算子は PHP 5 から使用可能になりました。
    それ以前には <function>is_a</function> が使用されていましたが、
    現在は <function>is_a</function> は推奨されておらず、
    <literal>instanceof</literal> の使用が推奨されています。
    PHP 5.3.0 以降、<function>is_a</function> は非推奨ではなくなったことに注意しましょう。
   </simpara>
   <para>
    <function>get_class</function> および
    <function>is_a</function> も参照ください。
   </para>
  </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
