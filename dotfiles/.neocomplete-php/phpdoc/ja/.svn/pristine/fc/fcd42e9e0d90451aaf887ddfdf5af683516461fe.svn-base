<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 337388 Maintainer: takagi Status: ready -->
<!-- CREDITS: hirokawa,shimooka -->
<sect1 xml:id="language.types.string">
 <title>文字列</title>

 <para>
  <type>string</type> は、文字が連結されたものです。PHP では、
  文字は 1 バイトと同じです。つまり、256 個の異なる文字を使用可能です。
  これは、PHP が Unicode をネイティブにサポートしていないことも意味します。
  <link linkend="language.types.string.details">文字列型の詳細</link>を参照ください。
 </para>

 <note>
  <simpara>
   文字列の最大長は 2GB (2147483647 バイト) です。
  </simpara>
 </note>

 <sect2 xml:id="language.types.string.syntax">
  <title>構文</title>

  <para>
   文字列リテラルは、4 つの異なる方法で指定することが可能です。
  </para>

  <itemizedlist>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.single">引用符</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.double">二重引用符</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.heredoc">ヒアドキュメント構文</link>
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     <link linkend="language.types.string.syntax.nowdoc">nowdoc 構文</link>
     (PHP 5.3.0 以降)
    </simpara>
   </listitem>
  </itemizedlist>

  <sect3 xml:id="language.types.string.syntax.single">
   <title>引用符</title>

   <para>
    文字列を指定する最も簡単な方法は、引用符 (文字
    <literal>'</literal>) で括ることです。
   </para>

   <para>
    引用符をリテラルとして指定するには、バックスラッシュ
    (<literal>\</literal>) でエスケープする必要があります。
    バックスラッシュをリテラルとして指定するには、二重
    (<literal>\\</literal>) にします。
    それ以外の場面で登場するバックスラッシュは、すべてバックスラッシュそのものとして扱われます。
    つまり、<literal>\r</literal> や <literal>\n</literal>
    といったおなじみのエスケープシーケンスを書いても特別な効果は得られず、
    書いたままの形式で出力されます。
   </para>

   <note>
    <simpara>
     <link linkend="language.types.string.syntax.double">ダブルクォート</link> 構文や
     <link linkend="language.types.string.syntax.heredoc">heredoc</link> 構文とは異なり、
     <link linkend="language.variables">変数</link>と特殊文字のエスケープシーケンスは、
     引用符 (シングルクオート) で括られた文字列にある場合には展開<emphasis>されません</emphasis>。
    </simpara>
   </note>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo 'this is a simple string';

echo 'You can also have embedded newlines in 
strings this way as it is
okay to do';

// 出力: Arnold once said: "I'll be back"
echo 'Arnold once said: "I\'ll be back"';

// 出力: You deleted C:\*.*?
echo 'You deleted C:\\*.*?';

// 出力: You deleted C:\*.*?
echo 'You deleted C:\*.*?';

// 出力: This will not expand: \n a newline
echo 'This will not expand: \n a newline';

// 出力: Variables do not $expand $either
echo 'Variables do not $expand $either';
?>
]]>
    </programlisting>
   </informalexample>

  </sect3>

  <sect3 xml:id="language.types.string.syntax.double">
   <title>二重引用符</title>

   <para>
    文字列が二重引用符 (") で括られた場合、
    PHP は、より多くの特殊文字のエスケープシーケンスを理解します。
   </para>

   <table>
    <title>エスケープされた文字</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>記述</entry>
       <entry>意味</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>ラインフィード (LF またはアスキーの 0x0A (10))</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>キャリッジリターン (CR またはアスキーの 0x0D (13))</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>水平タブ (HT またはアスキーの 0x09 (9))</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>垂直タブ (VT またはアスキーの 0x0B (11)) (PHP 5.2.5 以降)</entry>
      </row>
      <row>
       <entry><literal>\e</literal></entry>
       <entry>エスケープ (ESC あるいはアスキーの 0x1B (27)) (PHP 5.4.4 以降)</entry>
      </row>
      <row>
       <entry><literal>\f</literal></entry>
       <entry>フォームフィード (FF またはアスキーの 0x0C (12)) (PHP 5.2.5 以降)</entry>
      </row>
      <row>
       <entry><literal>\\</literal></entry>
       <entry>バックスラッシュ</entry>
      </row>
      <row>
       <entry><literal>\$</literal></entry>
       <entry>ドル記号</entry>
      </row>
      <row>
       <entry><literal>\"</literal></entry>
       <entry>二重引用符</entry>
      </row>
      <row>
       <entry><literal>\[0-7]{1,3}</literal></entry>
       <entry>
        正規表現にマッチする文字シーケンスは、8 進数表記の 1 文字です。
       </entry>
      </row>
      <row>
       <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
       <entry>
        正規表現にマッチする文字シーケンスは、16 進数表記の 1 文字です。
       </entry>
      </row>
      <row>
       <entry><literal>\u{[0-9a-f]{1,6}}</literal></entry>
       <entry>
        正規表現にマッチする文字シーケンスは、Unicode のコードポイントです。
        そのコードポイントの UTF-8 表現を文字列として出力します (PHP 7.0.0 で追加されました)。
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    繰り返しますが、この他の文字をエスケープしようとした場合には、
    バックスラッシュも出力されます!
    PHP 5.1.1 より前のバージョンでは、<literal>\{$var}</literal>
    のバックスラッシュは出力されません。
   </para>

   <para>
    しかし、二重引用符で括られた文字列で最も重要なのは、
    変数名が展開されるところです。詳細は、<link
    linkend="language.types.string.parsing">文字列のパース</link>を参照ください。
   </para>
  </sect3>
  
  <sect3 xml:id="language.types.string.syntax.heredoc">
   <title>ヒアドキュメント</title>

   <simpara>
    文字列を区切る別の方法としてヒアドキュメント構文 ("&lt;&lt;&lt;")
    があります。この場合、ある ID (と、それに続けて改行文字)
    を <literal>&lt;&lt;&lt;</literal>
    の後に指定し、文字列を置いた後で、同じ ID を括りを閉じるために置きます。
   </simpara>

   <simpara>
    終端 ID は、その行の最初のカラムから始める必要があります。
    使用するラベルは、PHP の他のラベルと同様の命名規則に従う必要があります。
    つまり、英数字およびアンダースコアのみを含み、
    数字でない文字またはアンダースコアで始まる必要があります。
   </simpara>
   
   <warning>
    <simpara>
     非常に重要なことですが、終端 ID がある行には、セミコロン
     (<literal>;</literal>) 以外の他の文字が含まれていてはならないことに注意しましょう。
     これは、特に ID はインデントしてはならないということ、
     セミコロンの前に空白やタブを付けてはいけないことを意味します。
     終端 ID の前の最初の文字は、使用するオペレーティングシステムで定義された
     改行である必要があることにも注意を要します。
     これは、例えば、Macintoshでは <literal>\r</literal> となります。
     最後の区切り文字の後にもまた、改行を入れる必要があります。
    </simpara>

    <simpara>
     この規則が破られて終端 ID が "clean" でない場合、
     終端 ID と認識されず、PHP はさらに終端 ID を探し続けます。
     適当な終了 ID がみつからない場合、
     スクリプトの最終行でパースエラーが発生します。
    </simpara>

    <para>
     ヒアドキュメント構文を、クラスのプロパティの初期化に用いることはできません。
     PHP 5.3 以降では、変数を含まないヒアドキュメントではこの制約はなくなりました。
    </para>

    <example>
     <title>間違った例</title>
     <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
    EOT;
}
?>
]]>
     </programlisting>
    </example>
   </warning>

   <para>
    ヒアドキュメントは二重引用符を使用しませんが、
    二重引用符で括られた文字列と全く同様に動作します。
    しかし、この場合でも上記のリストでエスケープされたコードを使用することも可能です。
    変数は展開されますが、文字列の場合と同様に
    ヒアドキュメントの内部で複雑な変数を表わす場合には注意が必要です。
   </para>

   <example> 
    <title>ヒアドキュメントで文字列を括る例</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Example of string
spanning multiple lines
using heredoc syntax.
EOD;

/* 変数を使用するより複雑な例 */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<EOT
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should print a capital 'A': \x41
EOT;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
My name is "MyName". I am printing some Foo.
Now, I am printing some Bar2.
This should print a capital 'A': A]]>
    </screen>
   </example>

   <para>
    ヒアドキュメント構文を用いて、
    関数の引数にデータを渡すこともできます。
   </para>

   <example> 
    <title>ヒアドキュメントを引数に使用する例</title>
    <programlisting role="php">
<![CDATA[
<?php
var_dump(array(<<<EOD
foobar!
EOD
));
?>
]]>
    </programlisting>
   </example>

   <para>
    PHP 5.3.0 以降、静的な変数やクラスのプロパティ/定数を
    ヒアドキュメント構文で初期化できるようになりました。
   </para>

   <example> 
    <title>ヒアドキュメントを用いた静的な値の初期化</title>
    <programlisting role="php">
<![CDATA[
<?php
// 静的変数
function foo()
{
    static $bar = <<<LABEL
Nothing in here...
LABEL;
}

// クラスのプロパティ/定数
class foo
{
    const BAR = <<<FOOBAR
Constant example
FOOBAR;

    public $baz = <<<FOOBAR
Property example
FOOBAR;
}
?>
]]>
    </programlisting>
   </example>

   <para>
    PHP 5.3.0 以降では、ヒアドキュメントの宣言をダブルクォートで囲めるようにもなりました。
   </para>

   <example> 
    <title>ヒアドキュメントでのダブルクォート</title>
    <programlisting role="php">
<![CDATA[
<?php
echo <<<"FOOBAR"
Hello World!
FOOBAR;
?>
]]>
    </programlisting>
   </example>

  </sect3>
  
  <sect3 xml:id="language.types.string.syntax.nowdoc">
   <title>Nowdoc</title>
   
   <para>
    Nowdoc はヒアドキュメントと似ていますが、
    ヒアドキュメントがダブルクォートで囲んだ文字列として扱われるのに対して、
    Nowdoc はシングルクォートで囲んだ文字列として扱われます。
    Nowdoc の使用方法はヒアドキュメントとほぼ同じですが、
    その中身について <emphasis>パース処理を行いません</emphasis>。
    PHP のコードや大量のテキストを埋め込む際に、
    エスケープが不要になるので便利です。この機能は、SGML の
    <literal>&lt;![CDATA[ ]]&gt;</literal>
    (ブロック内のテキストをパースしないことを宣言する)
    と同じようなものです。
   </para>
   
   <para>
    Nowdoc の書き方は、ヒアドキュメントと同じように
    <literal>&lt;&lt;&lt;</literal> を使用します。
    しかし、その後に続く識別子をシングルクォートで囲んで
    <literal>&lt;&lt;&lt;'EOT'</literal> のようにします。
    ヒアドキュメントの識別子に関する決まりがすべて Nowdoc
    の識別子にも当てはまります。特に終了識別子の書き方に関する決まりに注意しましょう。
   </para>
   
   <example>
    <title>Nowdoc による文字列のクォートの例</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = <<<'EOD'
Example of string
spanning multiple lines
using nowdoc syntax.
EOD;

/* 変数を使った、より複雑な例 */
class foo
{
    public $foo;
    public $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<'EOT'
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should not print a capital 'A': \x41
EOT;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should not print a capital 'A': \x41]]>
    </screen>
   </example>
   
   <example>
    <title>静的データの例</title>
    <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<'EOT'
bar
EOT;
}
?>
]]>
    </programlisting>
   </example>

   <note>
    <para>
     Nowdoc のサポートは PHP 5.3.0 で追加されました。
    </para>
   </note>
  </sect3>

  <sect3 xml:id="language.types.string.parsing">
   <title>変数のパース</title>

   <simpara>
    スクリプトが二重引用符で括られるかヒアドキュメントで指定された場合、
    その中の<link linkend="language.variables">変数</link>はパースされます。
   </simpara>

   <simpara>
    構文の型には、<link
    linkend="language.types.string.parsing.simple">単純な</link>構文と
    <link linkend="language.types.string.parsing.complex">複雑な
    </link>構文の 2 種類があります。簡単な構文は、最も一般的で便利です。
    この構文では、変数、配列値やオブジェクトのプロパティをパースすることが可能です。
   </simpara>

   <simpara>
    複雑な構文は、式を波括弧で括ることにより認識されます。
   </simpara>

   <sect4 xml:id="language.types.string.parsing.simple">
    <title>簡単な構文</title>

    <simpara>
     ドル記号 (<literal>$</literal>) を見付けると、
     パーサは、有効な変数名を形成することが可能な最長のトークンを取得します。
     変数名の終りを明示的に指定したい場合は、変数名を波括弧で括ってください。
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$juice = "apple";

echo "He drank some $juice juice.".PHP_EOL;
// 動作しません。"s" は、変数名として有効な文字ですが、実際の変数名は $juice です。
echo "He drank some juice made of $juices.";
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
He drank some apple juice.
He drank some juice made of .
]]>
     </screen>
    </informalexample>

    <simpara>
     同様に、配列添字とオブジェクトのプロパティをパースすることも可能です。
     配列添字の場合、閉じ角括弧 (<literal>]</literal>) は添字の終りを意味します。
     シンプルな変数の場合と同じ規則が、オブジェクトのプロパティに対しても適用されます。
    </simpara>

    <example><title>簡単な構文の例</title>
     <programlisting role="php">
<![CDATA[
<?php
$juices = array("apple", "orange", "koolaid1" => "purple");

echo "He drank some $juices[0] juice.".PHP_EOL;
echo "He drank some $juices[1] juice.".PHP_EOL;
echo "He drank some $juices[koolaid1] juice.".PHP_EOL;

class people {
    public $john = "John Smith";
    public $jane = "Jane Smith";
    public $robert = "Robert Paulsen";
    
    public $smith = "Smith";
}

$people = new people();

echo "$people->john drank some $juices[0] juice.".PHP_EOL;
echo "$people->john then said hello to $people->jane.".PHP_EOL;
echo "$people->john's wife greeted $people->robert.".PHP_EOL;
echo "$people->robert greeted the two $people->smiths."; // 動作しません
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
He drank some apple juice.
He drank some orange juice.
He drank some purple juice.
John Smith drank some apple juice.
John Smith then said hello to Jane Smith.
John Smith's wife greeted Robert Paulsen.
Robert Paulsen greeted the two .
]]>
     </screen>
    </example>

    <simpara>
     より複雑な場合は、複雑な構文を使用する必要があります。
    </simpara>
   </sect4>

   <sect4 xml:id="language.types.string.parsing.complex">
    <title>複雑な (波括弧) 構文</title>

    <simpara>
     この構文が「複雑(complex)な構文」と呼ばれているのは、
     構文が複雑であるからではなく、
     この方法では複雑な式を含めることができるからです。
    </simpara>

    <simpara>
     どんなスカラー変数、配列の要素あるいはオブジェクトのプロパティの文字列表現であっても
     この構文で含めることができます。
     文字列の外側に置く場合と同様に式を書き、これを
     { と } の間に含めてください。'{' はエスケープすることができないため、
     この構文は $ が { のすぐ後に続く場合にのみ認識されます
     (リテラル "{$" を指定するには、"{\$" を使用してください)。
     以下のいくつかの例を見ると理解しやすくなるでしょう。
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// すべてのエラーを表示します
error_reporting(E_ALL);

$great = 'fantastic';

// うまく動作しません。出力: This is { fantastic}
echo "This is { $great}";

// うまく動作します。出力: This is fantastic
echo "This is {$great}";
echo "This is ${great}";

// 動作します
echo "This square is {$square->width}00 centimeters broad."; 


// 動作します。クォートしたキーを使う場合は、波括弧構文を使わなければなりません
echo "This works: {$arr['key']}";


// 動作します
echo "This works: {$arr[4][3]}";

// これが動作しない理由は、文字列の外で $foo[bar]
// が動作しない理由と同じです。
// 言い換えると、これは動作するともいえます。しかし、
// PHP はまず最初に foo という名前の定数を探すため、
// E_NOTICE レベルのエラー(未定義の定数) となります。
echo "This is wrong: {$arr[foo][3]}"; 

// 動作します。多次元配列を使用する際は、
// 文字列の中では必ず配列を波括弧で囲むようにします。
echo "This works: {$arr['foo'][3]}";

// 動作します
echo "This works: " . $arr['foo'][3];

echo "You can even write {$obj->values[3]->name}";

echo "This is the value of the var named $name: {${$name}}";

echo "This is the value of the var named by the return value of getName(): {${getName()}}";

echo "This is the value of the var named by the return value of \$object->getName(): {${$object->getName()}}";

// 動作しません。出力: This is the return value of getName(): {getName()}
echo "This is the return value of getName(): {getName()}";
?>
]]>
<!-- maybe it's better to leave this out?? 
// this works, but i disencourage its use, since this is NOT 
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
     </programlisting>
    </informalexample>

    <para>
     文字列内で、変数を使ってクラスのプロパティにアクセスすることもできます。
     このような構文を使います。
    </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class foo {
    var $bar = 'I am bar.';
}

$foo = new foo();
$bar = 'bar';
$baz = array('foo', 'bar', 'baz', 'quux');
echo "{$foo->$bar}\n";
echo "{$foo->$baz[1]}\n";
?>
]]>
    </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
I am bar.
I am bar.
]]>
   </screen>
   </informalexample>
    
    <note>
     <para>
      <literal>{$}</literal> の内部における
      関数やメソッドのコール、静的クラス変数、クラス定数は、PHP 5 から動作します。
      しかし、アクセスする値は文字列が定義されたスコープにおける変数名として解釈します。
      ひとつの波括弧 (<literal>{}</literal>) では、
      関数やメソッドの返り値、クラス定数や静的クラス変数の値にはアクセスできません。
     </para>
    </note>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// すべてのエラーを表示します
error_reporting(E_ALL);

class beers {
    const softdrink = 'rootbeer';
    public static $ale = 'ipa';
}

$rootbeer = 'A & W';
$ipa = 'Alexander Keith\'s';

// これは動作し、出力は I'd like an A & W となります
echo "I'd like an {${beers::softdrink}}\n";

// これも動作し、出力は I'd like an Alexander Keith's となります
echo "I'd like an {${beers::$ale}}\n";
?>
]]>
     </programlisting>
    </informalexample>

   </sect4>
  </sect3>
  
  <sect3 xml:id="language.types.string.substr">
   <title>文字列への文字単位のアクセスと修正</title>

   <para>
    <varname>$str[42]</varname> のように、
    角括弧を使用してゼロから始まるオフセットを指定すると、
    文字列内の任意の文字にアクセスし、修正することが可能です。
    つまり、文字列を文字の配列として考えるわけです。
    複数の文字を取り出したり変更したりしたいときは、関数
    <function>substr</function> および <function>substr_replace</function>
    が使えます。
   </para>

   <note>
    <simpara>
     <varname>$str{42}</varname> のように波括弧を使用してアクセスすることも可能です。
    </simpara>
   </note>

   <warning>
    <simpara>
     範囲外のオフセットに書き込んだ場合は、空いた部分に空白文字が埋められます。
     整数型以外の型は整数型に変換されます。
     無効なオフセット形式を指定した場合は <constant>E_NOTICE</constant> を発行します。
     負のオフセットを指定した場合は、書き込み時は <constant>E_NOTICE</constant>
     を発行しますが読み込み時は空の文字列を返します。
     文字列を代入した場合は最初の文字だけを使用します。
     空文字列を代入した場合は NULL バイトを代入します。
    </simpara>
   </warning>

   <warning>
    <simpara>
     内部的には、PHP の文字列はバイト配列です。
     そのため、角括弧を使った配列形式での文字列へのアクセスは、
     マルチバイト対応ではありません。この方法は、
     ISO-8859-1 のようなシングルバイトエンコーディングの文字列に対してだけしか使えません。
    </simpara>
   </warning>

   <example>
    <title>文字列の例</title>
    <programlisting role="php">
<![CDATA[
<?php
// 文字列の最初の文字を取得します
$str = 'This is a test.';
$first = $str[0];

// 文字列の 3 番目の文字を取得します
$third = $str[2];

// 文字列の最後の文字を取得します
$str = 'This is still a test.';
$last = $str[strlen($str)-1]; 

// 文字列の最後の文字を変更します
$str = 'Look at the sea';
$str[strlen($str)-1] = 'e';

// {} を使用した、もうひとつの方法 (PHP 6 で廃止予定) です
$third = $str{2};

?>
]]>
    </programlisting>
   </example>
   
   <para>
    PHP 5.4 以降では、文字列のオフセットは整数あるいは整数と見なせる文字列に限られるようになりました。
    それ以外の場合は警告が発生します。以前のバージョンでは、たとえば
    <literal>"foo"</literal> のようなオフセットを指定しても単に <literal>0</literal> にキャストされるだけでした。
   </para>

   <example>
    <title>PHP 5.3 と PHP 5.4 の違い</title>
    <programlisting role="php">
<![CDATA[
<?php
$str = 'abc';

var_dump($str['1']);
var_dump(isset($str['1']));

var_dump($str['1.0']);
var_dump(isset($str['1.0']));

var_dump($str['x']);
var_dump(isset($str['x']));

var_dump($str['1x']);
var_dump(isset($str['1x']));
?>
]]>
    </programlisting>
    &example.outputs.53;
    <screen>
<![CDATA[
string(1) "b"
bool(true)
string(1) "b"
bool(true)
string(1) "a"
bool(true)
string(1) "b"
bool(true)
]]>
    </screen>
    &example.outputs.54;
    <screen>
<![CDATA[
string(1) "b"
bool(true)

Warning: Illegal string offset '1.0' in /tmp/t.php on line 7
string(1) "b"
bool(false)

Warning: Illegal string offset 'x' in /tmp/t.php on line 9
string(1) "a"
bool(false)
string(1) "b"
bool(false)
]]>
    </screen>
   </example>

   <note>
    <para>
     その他の型の変数
     (配列や、適切なインターフェイスを実装したオブジェクトを除く)
     に対して <literal>[]</literal> や <literal>{}</literal>
     でアクセスすると、何もメッセージを出さずに単に &null; を返します。
    </para>
   </note>

   <note>
    <para>
     PHP 5.5 以降では、文字列リテラル内の文字に対して
     <literal>[]</literal> や <literal>{}</literal> でアクセスできるようになりました。
    </para>
   </note>
  </sect3>
 </sect2><!-- end syntax -->

 <sect2 xml:id="language.types.string.useful-funcs">
  <title>便利な関数および演算子</title>

  <para>
   文字列は、'.' (ドット) 結合演算子で結合することが可能です。'+'
   (加算) 演算子はこの例では出てこないことに注意してください。詳細については
   <link linkend="language.operators.string">文字列演算子</link>
   を参照ください。
  </para>

  <para>
   文字列の修正を行う場合には、便利な関数がたくさん用意されています。
  </para>

  <simpara>
   一般的な関数については、<link linkend="ref.strings">文字列関数の節</link>
   を参照ください。高度な検索/置換を行う正規表現関数については
   <link linkend="ref.pcre">Perl</link> および
   <link linkend="ref.regex">POSIX 拡張</link> の 2 種類がありますが、
   それぞれの節を参照ください。
  </simpara>

  <simpara>
   <link linkend="ref.url">URL 文字列用関数</link>や文字列の暗号化/
   復号用の関数 (<link linkend="ref.mcrypt">mcrypt</link> および
   <link linkend="ref.mhash">mhash</link>) もあります。
  </simpara>

  <simpara>
   最後に、探しているものがまだ見付からない場合には、
   <link linkend="ref.ctype">文字型の関数</link>も参照ください。
  </simpara>
 </sect2>

 <sect2 xml:id="language.types.string.casting">
  <title>文字列への変換</title>
  
  <para>
   <literal>(string)</literal> キャストや <function>strval</function>
   関数を使って変数を文字列へ変換することができます。
   文字列型を必要とする式のスコープにおいて、文字列への変換は自動的に行われます。
   <function>echo</function> や <function>print</function> 関数を使うとき、
   あるいは可変変数を文字列を比較するときにこの自動変換が行われます。
   マニュアルの<link linkend="language.types">型</link> と
   <link linkend="language.types.type-juggling">型の相互変換</link>
   の項を読むとわかりやすいでしょう。
   <function>settype</function>も参照してください。
  </para>
  
  <para>
   <type>boolean</type> の &true; は文字列の <literal>"1"</literal> に、
   &false; は <literal>""</literal> (空文字列) に変換されます。
   これにより boolean と文字列の値を相互に変換することができます。
  </para>

  <para> 
   <type>integer</type> (整数) や浮動小数点数 (<type>float</type>) は
   その数値の数字として文字列に変換されます (指数の表記や浮動小数点数を含めて)。
   浮動小数点数は、指数表記
   (<literal>4.1E+6</literal>) を使用して変換されます。
  </para>

  <note>
   <para>
    小数点を表す文字は、スクリプトのロケール (LC_NUMERIC カテゴリ)
    によって決まります。
    <function>setlocale</function> を参照ください。
   </para>
  </note>

  <para>
   配列は常に <literal>"Array"</literal> という文字列に変換されるので、
   <type>array</type> の中を見るために <function>echo</function> や
   <function>print</function> を使ってダンプさせることはできません。
   一つの要素を見るためには、<literal>echo $arr['foo']</literal>
   のようにしてください。内容の全てをダンプ/見るためには以降の TIP をご覧ください。
  </para>

  <para>
   PHP 4 のオブジェクトは、常に <literal>"Object"</literal> という文字列に変換されます。
   デバッグ等のために <type>object</type> の内部の変数を出力するような場合には、
   以下をご覧ください。オブジェクトがなんという名前のクラスの
   インスタンスなのかを知るには <function>get_class</function> をご覧ください。
   PHP 5 以降では、もし存在すれば __toString() メソッドを使用します。
  </para>

  <para>
   リソースは常に <literal>"Resource id #1"</literal>
   という文字列に変換されます。<literal>1</literal> は実行中の
   PHP によって割り当てられる
   <type>resource</type> の番号です。
   この文字列の構造に依存したコードを書いてはいけません (この構造は変わる可能性があります)
   が、スクリプトの実行中 (ウェブのリクエストや CLI プロセスの処理中) は、指定したリソースに対してこの文字列が一意に割り当てられることが保証されます。
   他のリソースで同じ文字列が再利用されることはありません。
   リソースの型を知るためには <function>get_resource_type</function>
   を使用してください。
  </para>

  <para>
   &null; は常に空文字列に変換されます。
  </para>
  
  <para>
   以上に述べたように、配列、オブジェクト、リソースをプリントアウトしても
   その値に関する有益な情報を得られるわけではありません。
   デバッグのために値を出力するのによりよい方法が知りたければ、
   <function>print_r</function> や
   <function>var_dump</function> を参照ください。
  </para>
  
  <para>
   PHP 変数を恒久的に保存するための文字列に変換することもできます。
   この方法はシリアライゼーションと呼ばれ、
   <function>serialize</function> 関数によって実現できます。
   <link linkend="ref.wddx">WDDX</link> サポートを有効にして PHP
   をセットアップすれば、PHP 変数を XML 構造にシリアライズすることもできます。
  </para>
 </sect2>

 <sect2 xml:id="language.types.string.conversion">
  <title>文字列の数値への変換</title>

  <simpara>
   数値として文字列が評価された時、結果の値と型は次のように定義されます。
  </simpara>

  <simpara>
   文字列の中に '.' や 'e'、'E' といった文字が含まれず、
   数値が integer 型の範囲内 (<constant>PHP_INT_MAX</constant>
   で定義されています) におさまる場合は
   <type>integer</type> として評価されます。それ以外の場合は、すべて
   <type>float</type> として評価されます。
  </simpara>

  <para>
   文字列の最初の部分により値が決まります。文字列が、
   有効な数値データから始まる場合、この値が使用されます。その他の場合、
   値は 0 (ゼロ) となります。有効な数値データは符号(オプション)の後に、
   1 つ以上の数字 (オプションとして小数点を 1 つ含む)、
   オプションとして指数部が続きます。指数部は 'e' または 'E' の後に
   1 つ以上の数字が続く形式です。
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";              // $foo は float です (11.5)
$foo = 1 + "-1.3e3";            // $foo は float です (-1299)
$foo = 1 + "bob-1.3e3";         // $foo は integer です (1)
$foo = 1 + "bob3";              // $foo は integer です (1)
$foo = 1 + "10 Small Pigs";     // $foo は integer です (11)
$foo = 1 + "10 Little Piggies"; // $foo は integer です (11)
$foo = "10.0 pigs " + 1;        // $foo は integer です (11)
$foo = "10.0 pigs " + 1.0;      // $foo は float です (11)
?>
]]>
   </programlisting>
  </informalexample>

  <simpara>
   この変換に関する詳細は、Unix のマニュアルページで
   strtod(3) を参照ください。
  </simpara>

  <para>
   本節の例を試したい場合、その例をカットアンドペーストしてから
   動作を確認するために次の行を挿入してください。
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
echo "\$foo==$foo; type is " . gettype ($foo) . "<br />\n";
?>
]]>
   </programlisting>
  </informalexample>

  <para>
   (C 言語で行われるように) 数値に変換することで
   一つの文字のコードを取得できると期待してはいけません。
   文字と文字コードを相互に変換するには <function>ord</function>
   および <function>chr</function> 関数を使用してください。
  </para>

 </sect2>

 <sect2 xml:id="language.types.string.details">
  
  <title>文字列型の詳細</title>
  
  <para>
   PHP における文字列型は、バイトの配列と整数値 (バッファ長) で実装されています。
   バイト列を文字列に変換する方法については何の情報も持っておらず、完全にプログラマ任せとなっています。
   文字列を構成する値には何の制限もありません。特に気をつけるべきなのは、
   値 <literal>0</literal> のバイト (いわゆる “NUL バイト”) を文字列内のどの部分にでも使えるという点です
   (しかし、このマニュアル上で「バイナリセーフではない」とされている一部の関数では、
   受け取った文字列をライブラリに渡すときに NUL バイト以降を無視することがあります)。
  </para>
  <para>
   PHP の文字列型の正体を知ってしまえば、なぜ PHP には「バイト型」が存在しないのかもわかります。
   つまり、文字列型がその役割を受け持っているのです。テキスト以外のデータ、
   たとえばネットワークソケットから読み込んだ任意のデータを返す関数も、
   文字列で値を返します。
  </para>
  <para>
   PHP が文字列に対して特定のエンコーディングを強制しないのなら、
   いったいどのようにして文字列リテラルをエンコードしているのでしょう?
   たとえば、文字列 <literal>"á"</literal> と同等なのは <literal>"\xE1"</literal> (ISO-8859-1)、
   <literal>"\xC3\xA1"</literal> (UTF-8, C form)、
   <literal>"\x61\xCC\x81"</literal> (UTF-8, D form) のどれでしょう?
   あるいはそれ以外の何かなのでしょうか?
   実は、文字列のエンコードはスクリプトファイルのエンコード方式に従って行われるというのが正解です。
   したがって、もしスクリプトが ISO-8859-1 で書かれているのなら、文字列も ISO-8859-1
   でエンコードされます。その他のエンコードの場合も同様です。
   しかし、Zend Multibyte が有効になっている場合は話が別です。
   この場合は、スクリプトはどんなエンコーディングで書いてもかまいません
   (明示的に宣言することもできるし、自動検出させることもできます)。
   スクリプトはその後で内部エンコーディングに変換されるので、
   文字列リテラルも内部エンコーディングと同じ方式で符号化されます。
   スクリプトのエンコーディング (あるいは、Zend Multibyte
   を有効にした場合の内部エンコーディング) には、一部制限があることに注意しましょう。
   ひとことで言うと、ASCII の上位互換 でなければならないということです。
   UTF-8 や ISO-8859-1 などがこれにあたります。
   しかし、状態に依存する
   (たとえば、同じバイト値が、先頭にあるときとシフト状態にあるときで違う意味になる)
   エンコーディングは、問題になる可能性があります。
  </para>
  <para>
   もちろん、利便性を考慮すれば、テキストを操作する関数が文字列のエンコードを扱う際に
   何らかの前提に基づかざるを得ないこともあります。
   残念ながら、PHP の各関数が文字列のエンコーディングを判断する方法はまったく統一されていません。
  </para>
  <itemizedlist>
   <listitem>
    <simpara>
     いくつかの関数は、文字列が何らかのシングルバイトエンコーディングで符号化されているものと見なします。
     しかし、文字列内の各バイトが必ずしも特定の文字に変換できなくてもかまいません。
     このタイプの関数は、<function>substr</function> や
     <function>strpos</function>、<function>strlen</function>、
     <function>strcmp</function> などです。
     これらの関数については、文字列を扱うというよりメモリ上のバッファを扱うものととらえてもよいでしょう。
     つまり、バイト列とバイトオフセットで考えるということです。
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     文字列のエンコーディングを受け取る関数もあります。
     エンコーディング情報を省略したときにはデフォルトを用意していることもあるでしょう。
     このタイプの関数の例は、<function>htmlentities</function> や
     大半の <link linkend="book.mbstring">mbstring</link> 関数です。
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     現在のロケール (<function>setlocale</function> を参照ください) を使うけれども、
     処理はバイト単位で行う関数もあります。
     このタイプの関数は <function>strcasecmp</function> や
     <function>strtoupper</function> そして <function>ucfirst</function> です。
     つまり、これらの関数はシングルバイトエンコーディングでしか使えず、
     さらにエンコーディングとロケールがマッチしていなければならないということです。
     たとえば、<literal>strtoupper("á")</literal> が正しく <literal>"Á"</literal>
     を返すには、ロケールを正しく設定したうえで <literal>á</literal>
     をシングルバイトで符号化しておかなければなりません。仮に UTF-8 を使っていたとすると、
     正しい結果は返されないでしょう。さらに、現在のロケール設定によっては
     返される文字列が壊れてしまう可能性もあります。
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     最後に、文字列が特定のエンコーディング (たいていは UTF-8)
     であることを前提としている関数があります。
     <link linkend="book.intl">intl</link> の関数や
     <link linkend="book.pcre">PCRE</link> の関数
     (<literal>u</literal> 修飾子を使う場合のみ)
     の多くがこのタイプになります。また、その関数の目的上、
     <function>utf8_decode</function> 関数は入力が UTF-8 であることを前提とし、
     <function>utf8_encode</function> 関数は入力が ISO-8859-1 であることを前提としています。
    </simpara>
   </listitem>
  </itemizedlist>

  <para>
   結局、Unicode を使うプログラムをきちんと書くには、
   うまく動かない関数の使わないよう注意するしかないということです。
   特にデータを破壊してしまう可能性のある関数の使用は避け、
   きちんと動作する関数を使うようにしましょう。
   <link linkend="book.intl">intl</link> や
   <link linkend="book.mbstring">mbstring</link>
   の関数を選択するとよいでしょう。
   しかし、Unicode をまともに扱える関数を使うというのは単なる始まりに過ぎません。
   たとえ関数側で Unicode を扱う機能があったとしても、
   Unicode の仕様に関する知識は不可欠です。
   たとえば、世の中には大文字と小文字しか存在しないという思い込みで作ったプログラムは、
   うまく動かない可能性があります。
  </para>
 </sect2>
</sect1><!-- end string -->
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
